package org.modelix.metamodel.generator

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import org.modelix.metamodel.*
import org.modelix.model.api.*
import java.nio.file.Path
import kotlin.reflect.KClass
import org.modelix.model.data.PropertyType

private val reservedPropertyNames: Set<String> = setOf(
    "constructor", // already exists on JS objects
) + IConcept::class.members.map { it.name }

class MetaModelGenerator(val outputDir: Path, val nameConfig: NameConfig = NameConfig()) {
    var alwaysUseNonNullableProperties: Boolean = true

    private val headerComment = "\ngenerated by modelix metamodel generator\n"

    private fun ProcessedProperty.asKotlinType(): TypeName {
        val nonNullableType = when (type) {
            PropertyType.STRING -> String::class.asTypeName()
            PropertyType.BOOLEAN -> Boolean::class.asTypeName()
            PropertyType.INT -> Int::class.asTypeName()
        }
        return if (!optional || alwaysUseNonNullableProperties) nonNullableType else nonNullableType.copy(nullable = true)
    }

    private fun FileSpec.write() {
        writeTo(outputDir)
    }

    private fun ProcessedLanguage.packageDir(): Path {
        val packageName = name
        var packageDir = outputDir
        if (packageName.isNotEmpty()) {
            for (packageComponent in packageName.split('.').dropLastWhile { it.isEmpty() }) {
                packageDir = packageDir.resolve(packageComponent)
            }
        }
        return packageDir
    }

    fun generateRegistrationHelper(classFqName: String, languages: IProcessedLanguageSet) {
        generateRegistrationHelper(classFqName, languages as ProcessedLanguageSet)
    }

    internal fun generateRegistrationHelper(classFqName: String, languages: ProcessedLanguageSet) {
        val typeName = ClassName(classFqName.substringBeforeLast("."), classFqName.substringAfterLast("."))
        val cls = TypeSpec.objectBuilder(typeName)
            .addProperty(PropertySpec.builder("languages", List::class.parameterizedBy(GeneratedLanguage::class))
                .initializer("listOf(" + languages.getLanguages().map { it.generatedClassName() }
                    .joinToString(", ") { it.canonicalName } + ")")
                .build())
            .addFunction(FunSpec.builder("registerAll").addStatement("""languages.forEach { it.register() }""").build())
            .build()

        FileSpec.builder(typeName.packageName, typeName.simpleName)
            .addFileComment(headerComment)
            .addType(cls)
            .build()
            .write()
    }

    fun generate(languages: IProcessedLanguageSet) {
        generate(languages as ProcessedLanguageSet)
    }

    private fun generate(languages: ProcessedLanguageSet) {
        for (language in languages.getLanguages()) {
            language.packageDir().toFile().listFiles()?.filter { it.isFile }?.forEach { it.delete() }
            val builder =
                FileSpec.builder(language.generatedClassName().packageName, language.generatedClassName().simpleName)
            val file = builder.addFileComment(headerComment)
                .addType(generateLanguage(language)).build()
            for (concept in language.getConcepts()) {
                generateConceptFile(concept)
            }
            file.write()
        }
    }

    private fun generateLanguage(language: ProcessedLanguage): TypeSpec {
        val builder = TypeSpec.objectBuilder(language.generatedClassName())
        val conceptNamesList = language.getConcepts()
            .joinToString(", ") { it.name }
        builder.addFunction(
            FunSpec.builder("getConcepts")
                .addModifiers(KModifier.OVERRIDE)
                .addCode(language.getConcepts().map { it.conceptObjectType() }.toListLiteralCodeBlock())
                .build()
        )
        builder.superclass(GeneratedLanguage::class)
        builder.addSuperclassConstructorParameter("\"${language.name}\"")
        for (concept in language.getConcepts()) {
            builder.addProperty(
                PropertySpec.builder(concept.name, concept.conceptWrapperInterfaceType())
                    .initializer("%T", concept.conceptWrapperInterfaceClass())
                    .build()
            )
        }
        return builder.build()
    }

    private fun generateConceptFile(concept: ProcessedConcept) {
        FileSpec.builder(concept.language.name, concept.name)
            .addFileComment(headerComment)
            .addType(generateConceptObject(concept))
            .addTypeAlias(TypeAliasSpec.builder("CN_" + concept.name, concept.conceptWrapperInterfaceType()).build())
            .addType(generateConceptWrapperInterface(concept))
//            .addType(generateConceptWrapperImpl(concept))
            .addType(generateNodeWrapperInterface(concept))
            .addType(generateNodeWrapperImpl(concept))
            .apply {
                // allow to write `nodes.myChildren` instead of `nodes.flatMap { it.myChildren }`
                for (feature in concept.getOwnRoles()) {
                    val receiverType = Iterable::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType())
                    when (feature) {
                        is ProcessedProperty -> {
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(feature.asKotlinType())
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", feature.generatedName).build()
                                    )
                                    .build()
                            )
                            addProperty(
                                PropertySpec.builder(
                                    "raw_" + feature.generatedName,
                                    List::class.asTypeName()
                                        .parameterizedBy(String::class.asTypeName().copy(nullable = true))
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", "raw_" + feature.generatedName)
                                            .build()
                                    )
                                    .build()
                            )
                        }

                        is ProcessedChildLink -> {
                            val targetType = feature.type.resolved.nodeWrapperInterfaceType()
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(targetType)
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return flatMap { it.%N }", feature.generatedName).build()
                                    )
                                    .build()
                            )
                        }

                        is ProcessedReferenceLink -> {
                            val targetType =
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional)
                            val rawTargetType = INode::class.asTypeName().copy(nullable = true)
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(targetType)
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", feature.generatedName).build()
                                    )
                                    .build()
                            )
                            addProperty(
                                PropertySpec.builder(
                                    "raw_" + feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(rawTargetType)
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", "raw_" + feature.generatedName)
                                            .build()
                                    )
                                    .build()
                            )
                        }
                    }
                }
            }
            .build().write()
    }

    private fun generateConceptObject(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.objectBuilder(concept.conceptObjectName()).apply {
            superclass(
                GeneratedConcept::class.asTypeName().parameterizedBy(
                    concept.nodeWrapperInterfaceType(),
                    concept.conceptWrapperInterfaceType()
                )
            )
            addSuperclassConstructorParameter("%S", concept.name)
            addSuperclassConstructorParameter(concept.abstract.toString())
            val instanceClassType = KClass::class.asClassName().parameterizedBy(concept.nodeWrapperImplType())
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::getInstanceClass.name)
                    .addModifiers(KModifier.OVERRIDE)
                    .addStatement("""return %T::class""", concept.nodeWrapperImplType())
                    .build()
            )
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::typed.name)
                    .addModifiers(KModifier.OVERRIDE)
                    .addStatement("""return %T""", concept.conceptWrapperInterfaceClass())
                    .build()
            )
            addProperty(
                PropertySpec.builder(IConcept::language.name, ILanguage::class, KModifier.OVERRIDE)
                    .initializer(concept.language.generatedClassName().simpleName)
                    .build()
            )
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::wrap.name)
                    .addModifiers(KModifier.OVERRIDE)
                    .addParameter("node", INode::class)
                    .addStatement("return %T(node)", concept.nodeWrapperImplType())
                    .build()
            )
            concept.uid?.let { uid ->
                addFunction(
                    FunSpec.builder(GeneratedConcept<*, *>::getUID.name)
                        .addModifiers(KModifier.OVERRIDE)
                        .addStatement(CodeBlock.of("return %S", uid).toString())
                        .build()
                )
            }
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::getDirectSuperConcepts.name)
                    .addModifiers(KModifier.OVERRIDE)
                    .addCode(
                        concept.getDirectSuperConcepts().map { it.conceptObjectType() }.toList()
                            .toListLiteralCodeBlock()
                    )
                    .returns(List::class.asTypeName().parameterizedBy(IConcept::class.asTypeName()))
                    .build()
            )
            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        val serializer = (if (!feature.optional || alwaysUseNonNullableProperties) {
                            when (feature.type) {
                                PropertyType.STRING -> MandatoryStringPropertySerializer::class
                                PropertyType.BOOLEAN -> MandatoryBooleanPropertySerializer::class
                                PropertyType.INT -> MandatoryIntPropertySerializer::class
                            }
                        } else {
                            when (feature.type) {
                                PropertyType.STRING -> OptionalStringPropertySerializer::class
                                PropertyType.BOOLEAN -> OptionalBooleanPropertySerializer::class
                                PropertyType.INT -> OptionalIntPropertySerializer::class
                            }
                        }).asTypeName()
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName,
                                GeneratedProperty::class.asClassName().parameterizedBy(feature.asKotlinType())
                            )
                                .initializer(
                                    """newProperty(%S, %S, %T, ${feature.optional})""",
                                    feature.originalName,
                                    feature.uid,
                                    serializer
                                )
                                .build()
                        )
                    }

                    is ProcessedChildLink -> {
                        val methodName = if (feature.multiple) "newChildListLink" else "newSingleChildLink"
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.generatedChildLinkType())
                                .initializer(
                                    """$methodName(%S, %S, ${feature.optional}, %T, %T::class)""",
                                    feature.originalName,
                                    feature.uid,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType()
                                )
                                .build()
                        )
                    }

                    is ProcessedReferenceLink -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.generatedReferenceLinkType())
                                .initializer(
                                    """newReferenceLink(%S, %S, ${feature.optional}, %T, %T::class)""",
                                    feature.originalName,
                                    feature.uid,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType()
                                )
                                .build()
                        )
                    }
                }
            }
        }.build()
    }

    private fun generateConceptWrapperInterface(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.interfaceBuilder(concept.conceptWrapperInterfaceClass()).apply {
            val nodeT = TypeVariableName("NodeT", ITypedNode::class, variance = KModifier.OUT)
            addTypeVariable(nodeT)
            addSuperinterface(IConceptOfTypedNode::class.asTypeName().parameterizedBy(nodeT))
            for (extended in concept.getDirectSuperConcepts()) {
                addSuperinterface(extended.conceptWrapperInterfaceClass().parameterizedBy(nodeT))
            }
            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> addProperty(
                        PropertySpec.builder(
                            feature.generatedName,
                            GeneratedProperty::class.asClassName().parameterizedBy(feature.asKotlinType())
                        )
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .build()
                    )

                    is ProcessedChildLink -> addProperty(
                        PropertySpec.builder(feature.generatedName, feature.generatedChildLinkType())
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .build()
                    )

                    is ProcessedReferenceLink -> addProperty(
                        PropertySpec.builder(feature.generatedName, feature.generatedReferenceLinkType())
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .build()
                    )
                }
            }

            addType(TypeSpec.companionObjectBuilder().apply {
                addSuperinterface(concept.conceptWrapperInterfaceType())
                val t = if (concept.abstract) IConceptOfTypedNode::class else INonAbstractConcept::class
                addSuperinterface(t.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType()))
                addFunction(
                    FunSpec.builder(IConceptOfTypedNode<*>::getInstanceInterface.name)
                        .addModifiers(KModifier.OVERRIDE)
                        .returns(KClass::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType()))
                        .addStatement("return %T::class", concept.nodeWrapperInterfaceType())
                        .build()
                )
                addFunction(
                    FunSpec.builder(ITypedConcept::untyped.name)
                        .returns(IConcept::class)
                        .addModifiers(KModifier.OVERRIDE)
                        .addStatement("return %T", concept.conceptObjectType())
                        .build()
                )
            }.build())
        }.build()
    }

    private fun generateNodeWrapperImpl(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.classBuilder(concept.nodeWrapperImplType()).apply {
            addModifiers(KModifier.OPEN)
            addProperty(
                PropertySpec.builder(
                    TypedNodeImpl::_concept.name,
                    concept.conceptWrapperInterfaceType(),
                    KModifier.OVERRIDE
                )
                    .getter(
                        FunSpec.getterBuilder().addStatement("""return %T""", concept.conceptWrapperInterfaceClass())
                            .build()
                    )
                    .build()
            )

            if (concept.extends.size > 1) {
                // fix kotlin warning about ambiguity in case of multiple inheritance
                addFunction(
                    FunSpec.builder(ITypedNode::unwrap.name)
                        .addModifiers(KModifier.OVERRIDE)
                        .returns(INode::class)
                        .addStatement("return " + TypedNodeImpl::wrappedNode.name)
                        .build()
                )
            }
            primaryConstructor(FunSpec.constructorBuilder().addParameter("_node", INode::class).build())
            if (concept.extends.isEmpty()) {
                superclass(TypedNodeImpl::class)
                addSuperclassConstructorParameter("_node")
            } else {
                superclass(concept.extends.first().resolved.nodeWrapperImplType())
                addSuperclassConstructorParameter("_node")
                for (extended in concept.extends.drop(1)) {
                    addSuperinterface(
                        extended.resolved.nodeWrapperInterfaceType(),
                        CodeBlock.of("%T(_node)", extended.resolved.nodeWrapperImplType())
                    )
                }
            }
            addSuperinterface(concept.nodeWrapperInterfaceType())
            for (feature in concept.getOwnAndDuplicateRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.asKotlinType())
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(unwrap(), %T.%N)""",
                                    TypedPropertyAccessor::class.asTypeName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build()
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                String::class.asTypeName().copy(nullable = true)
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(unwrap(), %T.%N.untyped())""",
                                    RawPropertyAccessor::class.asTypeName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build()
                        )
                    }

                    is ProcessedChildLink -> {
                        // TODO resolve link.type and ensure it exists
                        val accessorSubclass =
                            if (feature.multiple) ChildListAccessor::class else SingleChildAccessor::class
                        val type = accessorSubclass.asClassName()
                            .parameterizedBy(
                                feature.type.resolved.nodeWrapperInterfaceType()
                            )
                        addProperty(
                            PropertySpec.builder(feature.generatedName, type)
                                .addModifiers(KModifier.OVERRIDE)
                                .initializer(
                                    """%T(%N(), %T.%N, %T, %T::class)""",
                                    accessorSubclass.asTypeName(),
                                    ITypedNode::unwrap.name,
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType()
                                )
                                .build()
                        )
                    }

                    is ProcessedReferenceLink -> {
                        val accessorClass =
                            if (feature.optional) OptionalReferenceAccessor::class else MandatoryReferenceAccessor::class
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName,
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional)
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(%N(), %T.%N, %T::class)""",
                                    accessorClass.asTypeName(),
                                    ITypedNode::unwrap.name,
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                    feature.type.resolved.nodeWrapperInterfaceType()
                                )
                                .build()
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                INode::class.asTypeName().copy(nullable = true)
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(${ITypedNode::unwrap.name}(), %T.%N)""",
                                    RawReferenceAccessor::class.asClassName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build()
                        )
                    }
                }
            }
        }.build()
    }

    private fun generateNodeWrapperInterface(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.interfaceBuilder(concept.nodeWrapperInterfaceType()).apply {
            if (concept.extends.isEmpty()) addSuperinterface(ITypedNode::class.asTypeName())
            for (extended in concept.extends) {
                addSuperinterface(extended.resolved.nodeWrapperInterfaceType())
            }
            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.asKotlinType())
                                .mutable(true)
                                .build()
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                String::class.asTypeName().copy(nullable = true)
                            )
                                .mutable(true)
                                .build()
                        )
                    }

                    is ProcessedChildLink -> {
                        // TODO resolve link.type and ensure it exists
                        val accessorSubclass =
                            if (feature.multiple) ChildListAccessor::class else SingleChildAccessor::class
                        val type = accessorSubclass.asClassName()
                            .parameterizedBy(
                                feature.type.resolved.nodeWrapperInterfaceType()
                            )
                        addProperty(
                            PropertySpec.builder(feature.generatedName, type)
                                .build()
                        )
                    }

                    is ProcessedReferenceLink -> {
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName,
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional)
                            )
                                .mutable(true)
                                .build()
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                INode::class.asTypeName().copy(nullable = true)
                            )
                                .mutable(true)
                                .build()
                        )
                    }
                }
            }
        }.build()
    }

    private fun ProcessedConcept.conceptWrapperInterfaceType() =
        conceptWrapperInterfaceClass().parameterizedBy(nodeWrapperInterfaceType())

    private fun ProcessedConcept.conceptWrapperInterfaceClass() =
        ClassName(language.name, nameConfig.conceptWrapperInterface(name))

    private fun ProcessedLanguage.generatedClassName() = ClassName(name, nameConfig.languageClass(name))
    private fun ProcessedConcept.nodeWrapperInterfaceName() = nameConfig.nodeWrapperInterface(name)
    private fun ProcessedConcept.nodeWrapperImplName() = nameConfig.nodeWrapperImpl(name)
    private fun ProcessedConcept.conceptObjectName() = nameConfig.conceptObject(name)
    //private fun ProcessedConcept.conceptWrapperImplName() = nameConfig.conceptWrapperImplName(name)
    //private fun ProcessedConcept.conceptWrapperInterfaceName() = nameConfig.conceptWrapperInterfaceName(name)

    //private fun ProcessedConcept.getConceptFqName() = language.name + "." + name
    private fun ProcessedConcept.conceptObjectType() = ClassName(language.name, conceptObjectName())
    private fun ProcessedConcept.nodeWrapperImplType() = ClassName(language.name, nodeWrapperImplName())
    private fun ProcessedConcept.nodeWrapperInterfaceType() = ClassName(language.name, nodeWrapperInterfaceName())

    //private fun ProcessedRole.kotlinRef() = CodeBlock.of("%T.%N", concept.conceptObjectType(), generatedName)
    private fun ProcessedRole.returnKotlinRef() =
        CodeBlock.of("return %T.%N", concept.conceptObjectType(), generatedName)

    private fun ProcessedChildLink.generatedChildLinkType(): TypeName {
        val childConcept = type.resolved
        val linkClass = if (multiple) GeneratedChildListLink::class else GeneratedSingleChildLink::class
        return linkClass.asClassName().parameterizedBy(
            childConcept.nodeWrapperInterfaceType(), childConcept.conceptWrapperInterfaceType()
        )
    }

    private fun ProcessedReferenceLink.generatedReferenceLinkType(): TypeName {
        val targetConcept = type.resolved
        return GeneratedReferenceLink::class.asClassName().parameterizedBy(
            targetConcept.nodeWrapperInterfaceType(), targetConcept.conceptWrapperInterfaceType()
        )
    }
}

private fun List<TypeName>.toListLiteralCodeBlock(): CodeBlock {
    val list = this
    return CodeBlock.builder().apply {
        add("return listOf(\n")
        withIndent {
            for (element in list) {
                add("%T,\n", element)
            }
        }
        add(")")
    }.build()
}