package org.modelix.metamodel.generator

import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeAliasSpec
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.TypeVariableName
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.withIndent
import org.modelix.metamodel.ChildListAccessor
import org.modelix.metamodel.GeneratedChildListLink
import org.modelix.metamodel.GeneratedConcept
import org.modelix.metamodel.GeneratedLanguage
import org.modelix.metamodel.GeneratedMandatorySingleChildLink
import org.modelix.metamodel.GeneratedProperty
import org.modelix.metamodel.GeneratedReferenceLink
import org.modelix.metamodel.GeneratedSingleChildLink
import org.modelix.metamodel.IConceptOfTypedNode
import org.modelix.metamodel.INonAbstractConcept
import org.modelix.metamodel.IPropertyValueEnum
import org.modelix.metamodel.ITypedConcept
import org.modelix.metamodel.ITypedNode
import org.modelix.metamodel.MandatoryBooleanPropertySerializer
import org.modelix.metamodel.MandatoryEnumSerializer
import org.modelix.metamodel.MandatoryIntPropertySerializer
import org.modelix.metamodel.MandatoryReferenceAccessor
import org.modelix.metamodel.MandatoryStringPropertySerializer
import org.modelix.metamodel.OptionalBooleanPropertySerializer
import org.modelix.metamodel.OptionalEnumSerializer
import org.modelix.metamodel.OptionalIntPropertySerializer
import org.modelix.metamodel.OptionalReferenceAccessor
import org.modelix.metamodel.OptionalStringPropertySerializer
import org.modelix.metamodel.RawPropertyAccessor
import org.modelix.metamodel.RawReferenceAccessor
import org.modelix.metamodel.SingleChildAccessor
import org.modelix.metamodel.TypedNodeImpl
import org.modelix.metamodel.TypedPropertyAccessor
import org.modelix.model.api.IConcept
import org.modelix.model.api.ILanguage
import org.modelix.model.api.INode
import org.modelix.model.data.EnumPropertyType
import org.modelix.model.data.Primitive
import org.modelix.model.data.PrimitivePropertyType
import org.modelix.modelql.core.IFluxStep
import org.modelix.modelql.core.IMonoStep
import org.modelix.modelql.core.IProducingStep
import org.modelix.modelql.typed.TypedModelQL
import java.nio.file.Path
import kotlin.reflect.KClass

class MetaModelGenerator(val outputDir: Path, val nameConfig: NameConfig = NameConfig(), val modelqlOutputDir: Path? = null) {
    var alwaysUseNonNullableProperties: Boolean = true

    private val headerComment = "\ngenerated by modelix model-api-gen \n"

    private fun ProcessedProperty.asKotlinType(): TypeName {
        val nonNullableType = when (type) {
            is PrimitivePropertyType -> when ((type as PrimitivePropertyType).primitive) {
                Primitive.STRING -> String::class.asTypeName()
                Primitive.BOOLEAN -> Boolean::class.asTypeName()
                Primitive.INT -> Int::class.asTypeName()
            }
            is EnumPropertyType -> {
                val enumType = (type as EnumPropertyType)
                ClassName(enumType.pckg, enumType.enumName)
            }
            else -> { throw RuntimeException("Unexpected property type: $type") }
        }
        return if (!optional || alwaysUseNonNullableProperties) nonNullableType else nonNullableType.copy(nullable = true)
    }

    private fun FileSpec.write() {
        writeTo(outputDir)
    }

    private fun ProcessedLanguage.packageDir(): Path {
        val packageName = name
        var packageDir = outputDir
        if (packageName.isNotEmpty()) {
            for (packageComponent in packageName.split('.').dropLastWhile { it.isEmpty() }) {
                packageDir = packageDir.resolve(packageComponent)
            }
        }
        return packageDir
    }

    fun generateRegistrationHelper(classFqName: String, languages: IProcessedLanguageSet) {
        generateRegistrationHelper(classFqName, languages as ProcessedLanguageSet)
    }

    internal fun generateRegistrationHelper(classFqName: String, languages: ProcessedLanguageSet) {
        val typeName = ClassName(classFqName.substringBeforeLast("."), classFqName.substringAfterLast("."))
        val cls = TypeSpec.objectBuilder(typeName)
            .addProperty(
                PropertySpec.builder("languages", List::class.parameterizedBy(GeneratedLanguage::class))
                    .initializer(
                        "listOf(" + languages.getLanguages().map { it.generatedClassName() }
                            .joinToString(", ") { it.canonicalName } + ")",
                    )
                    .build(),
            )
            .addFunction(FunSpec.builder("registerAll").addStatement("""languages.forEach { it.register() }""").build())
            .build()

        FileSpec.builder(typeName.packageName, typeName.simpleName)
            .addFileComment(headerComment)
            .addType(cls)
            .build()
            .write()
    }

    fun generate(languages: IProcessedLanguageSet) {
        generate(languages as ProcessedLanguageSet)
    }

    private fun generate(languages: ProcessedLanguageSet) {
        for (language in languages.getLanguages()) {
            language.packageDir().toFile().listFiles()?.filter { it.isFile }?.forEach { it.delete() }
            val builder =
                FileSpec.builder(language.generatedClassName().packageName, language.generatedClassName().simpleName)
            val file = builder.addFileComment(headerComment)
                .addType(generateLanguage(language)).build()
            file.write()

            for (enum in language.getEnums()) {
                generateEnumFile(enum)
            }

            for (concept in language.getConcepts()) {
                generateConceptFile(concept)
                if (modelqlOutputDir != null && concept.getOwnRoles().isNotEmpty()) {
                    generateModelQLFile(concept)
                }
            }
        }
    }

    private fun generateLanguage(language: ProcessedLanguage): TypeSpec {
        val builder = TypeSpec.objectBuilder(language.generatedClassName())
        val conceptNamesList = language.getConcepts()
            .joinToString(", ") { it.name }
        builder.addFunction(
            FunSpec.builder("getConcepts")
                .returns(List::class.asClassName().parameterizedBy(IConcept::class.asTypeName()))
                .addModifiers(KModifier.OVERRIDE)
                .addCode(language.getConcepts().map { it.conceptObjectType() }.toListLiteralCodeBlock())
                .build(),
        )
        builder.superclass(GeneratedLanguage::class)
        builder.addSuperclassConstructorParameter("\"${language.name}\"")
        for (concept in language.getConcepts()) {
            builder.addProperty(
                PropertySpec.builder(concept.name, concept.conceptWrapperInterfaceType())
                    .initializer("%T", concept.conceptWrapperInterfaceClass())
                    .build(),
            )
        }
        return builder.build()
    }

    private fun generateEnumFile(enum: ProcessedEnum) {
        val constructorSpec = FunSpec.constructorBuilder()
            .addParameter("uid", String::class)
            .addParameter("presentation", String::class.asTypeName().copy(nullable = true))
            .build()

        val enumBuilder = TypeSpec.enumBuilder(enum.name)
            .addDeprecationIfNecessary(enum)
            .primaryConstructor(constructorSpec)
            .addSuperinterface(IPropertyValueEnum::class)
            .addProperty(
                PropertySpec.builder("uid", String::class)
                    .initializer("uid")
                    .build(),
            )
            .addProperty(
                PropertySpec.builder("presentation", String::class.asTypeName().copy(nullable = true))
                    .initializer("presentation")
                    .addModifiers(KModifier.OVERRIDE)
                    .build(),
            )

        val enumType = ClassName(enum.language.name, enum.name)
        val getLiteralFunBuilder = FunSpec.builder("getLiteralByMemberId")
            .returns(enumType)
            .addParameter("uid", String::class)
        val getLiteralCodeBuilder = CodeBlock.builder().beginControlFlow("return when (uid) {")

        for (member in enum.getAllMembers()) {
            enumBuilder.addEnumConstant(
                member.name,
                TypeSpec.anonymousClassBuilder()
                    .addSuperclassConstructorParameter("%S", member.uid)
                    .addSuperclassConstructorParameter(
                        if (member.presentation == null) "null" else "%S",
                        member.presentation ?: "",
                    )
                    .build(),
            )
            getLiteralCodeBuilder.addStatement("%S -> %N", member.uid, member.name)
        }

        getLiteralFunBuilder.addCode(
            getLiteralCodeBuilder
                .addStatement("else -> defaultValue()")
                .endControlFlow()
                .build(),
        )

        val companion = TypeSpec.companionObjectBuilder()
            .addFunction(
                FunSpec.builder("defaultValue")
                    .returns(enumType)
                    .addCode("return values()[%L]", enum.defaultIndex)
                    .build(),
            )
            .addFunction(
                getLiteralFunBuilder.build(),
            )
            .build()

        val generatedEnum = enumBuilder.addType(companion).build()

        FileSpec.builder(enum.language.name, enum.name)
            .addFileComment(headerComment)
            .addType(generatedEnum)
            .build()
            .write()
    }

    private fun generateConceptFile(concept: ProcessedConcept) {
        FileSpec.builder(concept.language.name, concept.name)
            .addFileComment(headerComment)
            .addType(generateConceptObject(concept))
            .addTypeAlias(TypeAliasSpec.builder(concept.conceptTypeAliasName(), concept.conceptWrapperInterfaceType()).build())
            .addType(generateConceptWrapperInterface(concept))
//            .addType(generateConceptWrapperImpl(concept))
            .addType(generateNodeWrapperInterface(concept))
            .addType(generateNodeWrapperImpl(concept))
            .apply {
                // allow to write `nodes.myChildren` instead of `nodes.flatMap { it.myChildren }`
                for (feature in concept.getOwnRoles()) {
                    val receiverType = Iterable::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType())
                    when (feature) {
                        is ProcessedProperty -> {
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(feature.asKotlinType()),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", feature.generatedName).build(),
                                    )
                                    .build(),
                            )
                            addProperty(
                                PropertySpec.builder(
                                    "raw_" + feature.generatedName,
                                    List::class.asTypeName()
                                        .parameterizedBy(String::class.asTypeName().copy(nullable = true)),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", "raw_" + feature.generatedName)
                                            .build(),
                                    )
                                    .build(),
                            )
                        }

                        is ProcessedChildLink -> {
                            val targetType = feature.type.resolved.nodeWrapperInterfaceType()
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(targetType),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return flatMap { it.%N }", feature.generatedName).build(),
                                    )
                                    .build(),
                            )
                        }

                        is ProcessedReferenceLink -> {
                            val targetType =
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional)
                            val rawTargetType = INode::class.asTypeName().copy(nullable = true)
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(targetType),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", feature.generatedName).build(),
                                    )
                                    .build(),
                            )
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName + "_orNull",
                                    List::class.asTypeName().parameterizedBy(targetType.copy(nullable = true)),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", feature.generatedName + "_orNull").build(),
                                    )
                                    .build(),
                            )
                            addProperty(
                                PropertySpec.builder(
                                    "raw_" + feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(rawTargetType),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", "raw_" + feature.generatedName)
                                            .build(),
                                    )
                                    .build(),
                            )
                        }
                    }
                }
            }
            .build().write()
    }

    private fun generateModelQLFile(concept: ProcessedConcept) {
        FileSpec.builder("org.modelix.modelql.gen." + concept.language.name, concept.name)
            .addFileComment(headerComment)
            .apply {
                for (feature in concept.getOwnRoles()) {
                    val receiverType = Iterable::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType())
                    when (feature) {
                        is ProcessedProperty -> {
                            for (stepType in listOf(IMonoStep::class.asTypeName(), IFluxStep::class.asTypeName())) {
                                val inputType = stepType.parameterizedBy(concept.nodeWrapperInterfaceType())
                                val outputElementType = when (feature.type) {
                                    is EnumPropertyType -> String::class.asTypeName().copy(nullable = true)
                                    is PrimitivePropertyType -> feature.asKotlinType()
                                }
                                val outputType = stepType.parameterizedBy(outputElementType)
                                val functionName = when (val type = feature.type) {
                                    is EnumPropertyType -> "rawProperty"
                                    is PrimitivePropertyType -> when (type.primitive) {
                                        Primitive.STRING -> "stringProperty"
                                        Primitive.BOOLEAN -> "booleanProperty"
                                        Primitive.INT -> "intProperty"
                                    }
                                }
                                addProperty(
                                    PropertySpec.builder(feature.generatedName, outputType)
                                        .receiver(inputType)
                                        .getter(
                                            FunSpec.getterBuilder()
                                                .addStatement(
                                                    "return %T.%N(this, %T.%N)",
                                                    TypedModelQL::class.asTypeName(),
                                                    functionName,
                                                    concept.conceptWrapperInterfaceClass(),
                                                    feature.generatedName,
                                                )
                                                .build(),
                                        )
                                        .build(),
                                )
                            }

                            val inputStepType = IMonoStep::class.asTypeName()
                                .parameterizedBy(concept.nodeWrapperInterfaceType())
                            addFunction(
                                FunSpec.builder(feature.setterName())
                                    .returns(inputStepType)
                                    .receiver(inputStepType)
                                    .addParameter("value", IMonoStep::class.asTypeName().parameterizedBy(feature.asKotlinType()))
                                    .addStatement(
                                        "return %T.setProperty(this, %T.%N, value)",
                                        TypedModelQL::class.asTypeName(),
                                        concept.conceptWrapperInterfaceClass(),
                                        feature.generatedName,
                                    )
                                    .build(),
                            )
                        }

                        is ProcessedChildLink -> {
                            val targetType = feature.type.resolved.nodeWrapperInterfaceType()

                            val inputStepType = (if (feature.multiple) IProducingStep::class else IMonoStep::class).asTypeName()
                            val outputStepType = (if (feature.multiple) IFluxStep::class else IMonoStep::class).asTypeName()
                            val inputType = inputStepType.parameterizedBy(concept.nodeWrapperInterfaceType())
                            val isOptionalSingle = feature.optional && !feature.multiple
                            val outputType = outputStepType.parameterizedBy(
                                targetType.copy(nullable = isOptionalSingle),
                            )
                            addProperty(
                                PropertySpec.builder(feature.generatedName, outputType)
                                    .receiver(inputType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement(
                                                "return %T.children(this, %T.%N)",
                                                TypedModelQL::class.asTypeName(),
                                                concept.conceptWrapperInterfaceClass(),
                                                feature.generatedName,
                                            )
                                            .build(),
                                    )
                                    .build(),
                            )
                        }

                        is ProcessedReferenceLink -> {
                            val targetType =
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional)

                            for (stepType in listOf(IMonoStep::class.asTypeName(), IFluxStep::class.asTypeName())) {
                                val inputType = stepType.parameterizedBy(concept.nodeWrapperInterfaceType())
                                val outputType = stepType.parameterizedBy(targetType.copy(nullable = false))
                                val outputTypeNullable = stepType.parameterizedBy(targetType.copy(nullable = true))
                                addProperty(
                                    PropertySpec.builder(feature.generatedName, outputType)
                                        .receiver(inputType)
                                        .getter(
                                            FunSpec.getterBuilder()
                                                .addStatement(
                                                    "return %T.reference(this, %T.%N)",
                                                    TypedModelQL::class.asTypeName(),
                                                    concept.conceptWrapperInterfaceClass(),
                                                    feature.generatedName,
                                                )
                                                .build(),
                                        )
                                        .build(),
                                )
                                addProperty(
                                    PropertySpec.builder(feature.generatedName + "_orNull", outputTypeNullable)
                                        .receiver(inputType)
                                        .getter(
                                            FunSpec.getterBuilder()
                                                .addStatement(
                                                    "return %T.referenceOrNull(this, %T.%N)",
                                                    TypedModelQL::class.asTypeName(),
                                                    concept.conceptWrapperInterfaceClass(),
                                                    feature.generatedName,
                                                )
                                                .build(),
                                        )
                                        .build(),
                                )
                            }
                        }
                    }
                }
            }
            .build().writeTo(modelqlOutputDir!!)
    }

    private fun generateConceptObject(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.objectBuilder(concept.conceptObjectName()).apply {
            superclass(
                GeneratedConcept::class.asTypeName().parameterizedBy(
                    concept.nodeWrapperInterfaceType(),
                    concept.conceptWrapperInterfaceType(),
                ),
            )
            addSuperclassConstructorParameter("%S", concept.name)
            addSuperclassConstructorParameter(concept.abstract.toString())
            val instanceClassType = KClass::class.asClassName().parameterizedBy(concept.nodeWrapperImplType())
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::getInstanceClass.name)
                    .returns(KClass::class.asClassName().parameterizedBy(concept.nodeWrapperImplType()))
                    .addModifiers(KModifier.OVERRIDE)
                    .addStatement("""return %T::class""", concept.nodeWrapperImplType())
                    .build(),
            )
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::typed.name)
                    .returns(concept.conceptWrapperInterfaceType())
                    .addModifiers(KModifier.OVERRIDE)
                    .addStatement("""return %T""", concept.conceptWrapperInterfaceClass())
                    .build(),
            )
            addProperty(
                PropertySpec.builder(IConcept::language.name, ILanguage::class, KModifier.OVERRIDE)
                    .initializer(concept.language.generatedClassName().simpleName)
                    .build(),
            )
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::wrap.name)
                    .returns(concept.nodeWrapperImplType())
                    .addModifiers(KModifier.OVERRIDE)
                    .addParameter("node", INode::class)
                    .addStatement("return %T(node)", concept.nodeWrapperImplType())
                    .build(),
            )
            concept.uid?.let { uid ->
                addFunction(
                    FunSpec.builder(GeneratedConcept<*, *>::getUID.name)
                        .returns(String::class)
                        .addModifiers(KModifier.OVERRIDE)
                        .addStatement(CodeBlock.of("return %S", uid).toString())
                        .build(),
                )
            }
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::getDirectSuperConcepts.name)
                    .addModifiers(KModifier.OVERRIDE)
                    .addCode(
                        concept.getDirectSuperConcepts().map { it.conceptObjectType() }.toList()
                            .toListLiteralCodeBlock(),
                    )
                    .returns(List::class.asTypeName().parameterizedBy(IConcept::class.asTypeName()))
                    .build(),
            )
            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        val serializer = (
                            if (!feature.optional || alwaysUseNonNullableProperties) {
                                when (feature.type) {
                                    is PrimitivePropertyType -> when ((feature.type as PrimitivePropertyType).primitive) {
                                        Primitive.STRING -> MandatoryStringPropertySerializer::class
                                        Primitive.BOOLEAN -> MandatoryBooleanPropertySerializer::class
                                        Primitive.INT -> MandatoryIntPropertySerializer::class
                                    }
                                    is EnumPropertyType -> MandatoryEnumSerializer::class
                                    else -> throw RuntimeException("Unexpected property type: ${feature.type}")
                                }
                            } else {
                                when (feature.type) {
                                    is PrimitivePropertyType -> when ((feature.type as PrimitivePropertyType).primitive) {
                                        Primitive.STRING -> OptionalStringPropertySerializer::class
                                        Primitive.BOOLEAN -> OptionalBooleanPropertySerializer::class
                                        Primitive.INT -> OptionalIntPropertySerializer::class
                                    }
                                    is EnumPropertyType -> OptionalEnumSerializer::class
                                    else -> throw RuntimeException("Unexpected property type: ${feature.type}")
                                }
                            }
                            ).asTypeName()

                        val propBuilder = PropertySpec.builder(
                            feature.generatedName,
                            GeneratedProperty::class.asClassName().parameterizedBy(feature.asKotlinType()),
                        )
                        if (feature.type is EnumPropertyType) {
                            if (serializer == MandatoryEnumSerializer::class.asTypeName()) {
                                propBuilder.initializer(
                                    """newProperty(%S, %S, %T({ it.uid },
                                        |{ if (it != null) %T.getLiteralByMemberId(it) else %T.defaultValue() }),
                                        |${feature.optional})
                                    """.trimMargin(),
                                    feature.originalName,
                                    feature.uid,
                                    serializer,
                                    feature.asKotlinType(),
                                    feature.asKotlinType(),
                                )
                            } else {
                                propBuilder.initializer(
                                    """newProperty(%S, %S, %T( { it.uid }, { %T.getLiteralByMemberId(it) }),
                                        |${feature.optional})
                                    """.trimMargin(),
                                    feature.originalName,
                                    feature.uid,
                                    serializer,
                                    feature.asKotlinType(),
                                )
                            }
                        } else {
                            propBuilder.initializer(
                                """newProperty(%S, %S, %T, ${feature.optional})""",
                                feature.originalName,
                                feature.uid,
                                serializer,
                            )
                        }
                        addProperty(propBuilder.build())
                    }

                    is ProcessedChildLink -> {
                        val methodName = if (feature.multiple) {
                            "newChildListLink"
                        } else {
                            if (feature.optional) {
                                "newOptionalSingleChildLink"
                            } else {
                                "newMandatorySingleChildLink"
                            }
                        }
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.generatedChildLinkType())
                                .initializer(
                                    """$methodName(%S, %S, ${if (feature.multiple) "${feature.optional}, " else ""}%T, %T::class)""",
                                    feature.originalName,
                                    feature.uid,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType(),
                                )
                                .build(),
                        )
                    }

                    is ProcessedReferenceLink -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.generatedReferenceLinkType())
                                .initializer(
                                    """newReferenceLink(%S, %S, ${feature.optional}, %T, %T::class)""",
                                    feature.originalName,
                                    feature.uid,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType(),
                                )
                                .build(),
                        )
                    }
                }
            }
        }.build()
    }

    private fun generateConceptWrapperInterface(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.interfaceBuilder(concept.conceptWrapperInterfaceClass()).apply {
            addDeprecationIfNecessary(concept)
            val nodeT = TypeVariableName("NodeT", concept.nodeWrapperInterfaceType(), variance = KModifier.OUT)
            addTypeVariable(nodeT)
            addSuperinterface(IConceptOfTypedNode::class.asTypeName().parameterizedBy(nodeT))
            for (extended in concept.getDirectSuperConcepts()) {
                addSuperinterface(extended.conceptWrapperInterfaceClass().parameterizedBy(nodeT))
            }

            for (metaPropertyName in concept.language.languageSet.getMetaPropertyRoots(concept.fqName())) {
                addProperty(
                    PropertySpec.builder(metaPropertyName, String::class.asTypeName().copy(nullable = true))
                        .getter(FunSpec.getterBuilder().addCode("return null").build())
                        .build(),
                )
            }

            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> addProperty(
                        PropertySpec.builder(
                            feature.generatedName,
                            GeneratedProperty::class.asClassName().parameterizedBy(feature.asKotlinType()),
                        )
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .addDeprecationIfNecessary(feature)
                            .build(),
                    )

                    is ProcessedChildLink -> addProperty(
                        PropertySpec.builder(feature.generatedName, feature.generatedChildLinkType())
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .addDeprecationIfNecessary(feature)
                            .build(),
                    )

                    is ProcessedReferenceLink -> addProperty(
                        PropertySpec.builder(feature.generatedName, feature.generatedReferenceLinkType())
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .addDeprecationIfNecessary(feature)
                            .build(),
                    )
                }
            }

            addType(
                TypeSpec.companionObjectBuilder().apply {
                    addSuperinterface(concept.conceptWrapperInterfaceType())
                    val t = if (concept.abstract) IConceptOfTypedNode::class else INonAbstractConcept::class
                    addSuperinterface(t.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType()))
                    addFunction(
                        FunSpec.builder(IConceptOfTypedNode<*>::getInstanceInterface.name)
                            .addModifiers(KModifier.OVERRIDE)
                            .returns(KClass::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType()))
                            .addStatement("return %T::class", concept.nodeWrapperInterfaceType())
                            .build(),
                    )
                    addFunction(
                        FunSpec.builder(ITypedConcept::untyped.name)
                            .returns(IConcept::class)
                            .addModifiers(KModifier.OVERRIDE)
                            .addStatement("return %T", concept.conceptObjectType())
                            .build(),
                    )
                    concept.metaProperties.forEach { (key, value) ->
                        addProperty(
                            PropertySpec.builder(key, String::class.asTypeName())
                                .addModifiers(KModifier.OVERRIDE)
                                .initializer("%S", value)
                                .build(),
                        )
                    }
                }.build(),
            )
        }.build()
    }

    private fun generateNodeWrapperImpl(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.classBuilder(concept.nodeWrapperImplType()).apply {
            addModifiers(KModifier.OPEN)
            addProperty(
                PropertySpec.builder(
                    TypedNodeImpl::_concept.name,
                    concept.conceptWrapperInterfaceType(),
                    KModifier.OVERRIDE,
                )
                    .getter(
                        FunSpec.getterBuilder().addStatement("""return %T""", concept.conceptWrapperInterfaceClass())
                            .build(),
                    )
                    .build(),
            )

            if (concept.extends.size > 1) {
                // fix kotlin warning about ambiguity in case of multiple inheritance
                addFunction(
                    FunSpec.builder(ITypedNode::unwrap.name)
                        .addModifiers(KModifier.OVERRIDE)
                        .returns(INode::class)
                        .addStatement("return " + TypedNodeImpl::wrappedNode.name)
                        .build(),
                )
            }
            primaryConstructor(FunSpec.constructorBuilder().addParameter("_node", INode::class).build())
            if (concept.extends.isEmpty()) {
                superclass(TypedNodeImpl::class)
                addSuperclassConstructorParameter("_node")
            } else {
                superclass(concept.extends.first().resolved.nodeWrapperImplType())
                addSuperclassConstructorParameter("_node")
                for (extended in concept.extends.drop(1)) {
                    addSuperinterface(
                        extended.resolved.nodeWrapperInterfaceType(),
                        CodeBlock.of("%T(_node)", extended.resolved.nodeWrapperImplType()),
                    )
                }
            }
            addSuperinterface(concept.nodeWrapperInterfaceType())
            for (feature in concept.getOwnAndDuplicateRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.asKotlinType())
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(unwrap(), %T.%N)""",
                                    TypedPropertyAccessor::class.asTypeName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                String::class.asTypeName().copy(nullable = true),
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(unwrap(), %T.%N.untyped())""",
                                    RawPropertyAccessor::class.asTypeName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build(),
                        )
                    }

                    is ProcessedChildLink -> {
                        // TODO resolve link.type and ensure it exists
                        val accessorSubclass =
                            if (feature.multiple) ChildListAccessor::class else SingleChildAccessor::class
                        val type = accessorSubclass.asClassName()
                            .parameterizedBy(
                                feature.type.resolved.nodeWrapperInterfaceType(),
                            )
                        addProperty(
                            PropertySpec.builder(feature.generatedName, type)
                                .addModifiers(KModifier.OVERRIDE)
                                .initializer(
                                    """%T(%N(), %T.%N, %T, %T::class)""",
                                    accessorSubclass.asTypeName(),
                                    ITypedNode::unwrap.name,
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType(),
                                )
                                .build(),
                        )
                    }

                    is ProcessedReferenceLink -> {
                        val accessorClass =
                            if (feature.optional) OptionalReferenceAccessor::class else MandatoryReferenceAccessor::class
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName,
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional),
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(%N(), %T.%N, %T::class)""",
                                    accessorClass.asTypeName(),
                                    ITypedNode::unwrap.name,
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                    feature.type.resolved.nodeWrapperInterfaceType(),
                                )
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName + "_orNull",
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = true),
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(false)
                                .delegate(
                                    """%T(%N(), %T.%N, %T::class)""",
                                    OptionalReferenceAccessor::class.asTypeName(),
                                    ITypedNode::unwrap.name,
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                    feature.type.resolved.nodeWrapperInterfaceType(),
                                )
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                INode::class.asTypeName().copy(nullable = true),
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(${ITypedNode::unwrap.name}(), %T.%N)""",
                                    RawReferenceAccessor::class.asClassName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build(),
                        )
                    }
                }
            }
        }.build()
    }

    private fun generateNodeWrapperInterface(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.interfaceBuilder(concept.nodeWrapperInterfaceType()).apply {
            addDeprecationIfNecessary(concept)
            if (concept.extends.isEmpty()) addSuperinterface(ITypedNode::class.asTypeName())
            for (extended in concept.extends) {
                addSuperinterface(extended.resolved.nodeWrapperInterfaceType())
            }
            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.asKotlinType())
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                String::class.asTypeName().copy(nullable = true),
                            )
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build(),
                        )
                    }

                    is ProcessedChildLink -> {
                        // TODO resolve link.type and ensure it exists
                        val accessorSubclass =
                            if (feature.multiple) ChildListAccessor::class else SingleChildAccessor::class
                        val type = accessorSubclass.asClassName()
                            .parameterizedBy(
                                feature.type.resolved.nodeWrapperInterfaceType(),
                            )
                        addProperty(
                            PropertySpec.builder(feature.generatedName, type)
                                .addDeprecationIfNecessary(feature)
                                .build(),
                        )
                    }

                    is ProcessedReferenceLink -> {
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName,
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional),
                            )
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName + "_orNull",
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = true),
                            )
                                .mutable(false)
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                INode::class.asTypeName().copy(nullable = true),
                            )
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build(),
                        )
                    }
                }
            }
        }.build()
    }

    private fun generateDeprecationAnnotation(message: String): AnnotationSpec {
        val annotationBuilder = AnnotationSpec.builder(Deprecated::class)
        if (message.isNotEmpty()) { annotationBuilder.addMember("message = %S", message) }
        return annotationBuilder.build()
    }

    private fun TypeSpec.Builder.addDeprecationIfNecessary(deprecatable: IProcessedDeprecatable): TypeSpec.Builder {
        return deprecatable.deprecationMessage?.let { addAnnotation(generateDeprecationAnnotation(it)) } ?: this
    }

    private fun PropertySpec.Builder.addDeprecationIfNecessary(deprecatable: IProcessedDeprecatable): PropertySpec.Builder {
        return deprecatable.deprecationMessage?.let { addAnnotation(generateDeprecationAnnotation(it)) } ?: this
    }

    private fun ProcessedConcept.conceptWrapperInterfaceType() =
        conceptWrapperInterfaceClass().parameterizedBy(nodeWrapperInterfaceType())

    private fun ProcessedConcept.conceptWrapperInterfaceClass() =
        ClassName(language.name, nameConfig.typedConcept(name))

    private fun ProcessedLanguage.generatedClassName() = ClassName(name, nameConfig.languageClass(name))
    private fun ProcessedConcept.nodeWrapperInterfaceName() = nameConfig.typedNode(name)
    private fun ProcessedConcept.nodeWrapperImplName() = nameConfig.typedNodeImpl(name)
    private fun ProcessedConcept.conceptObjectName() = nameConfig.untypedConcept(name)
    private fun ProcessedConcept.conceptTypeAliasName() = nameConfig.conceptTypeAlias(name)
    // private fun ProcessedConcept.conceptWrapperImplName() = nameConfig.conceptWrapperImplName(name)
    // private fun ProcessedConcept.conceptWrapperInterfaceName() = nameConfig.conceptWrapperInterfaceName(name)

    // private fun ProcessedConcept.getConceptFqName() = language.name + "." + name
    private fun ProcessedConcept.conceptObjectType() = ClassName(language.name, conceptObjectName())
    private fun ProcessedConcept.nodeWrapperImplType() = ClassName(language.name, nodeWrapperImplName())
    private fun ProcessedConcept.nodeWrapperInterfaceType() = ClassName(language.name, nodeWrapperInterfaceName())

    // private fun ProcessedRole.kotlinRef() = CodeBlock.of("%T.%N", concept.conceptObjectType(), generatedName)
    private fun ProcessedRole.returnKotlinRef() =
        CodeBlock.of("return %T.%N", concept.conceptObjectType(), generatedName)

    private fun ProcessedChildLink.generatedChildLinkType(): TypeName {
        val childConcept = type.resolved
        val linkClass = if (multiple) {
            GeneratedChildListLink::class
        } else {
            if (optional) GeneratedSingleChildLink::class else GeneratedMandatorySingleChildLink::class
        }
        return linkClass.asClassName().parameterizedBy(
            childConcept.nodeWrapperInterfaceType(),
            childConcept.conceptWrapperInterfaceType(),
        )
    }

    private fun ProcessedReferenceLink.generatedReferenceLinkType(): TypeName {
        val targetConcept = type.resolved
        return GeneratedReferenceLink::class.asClassName().parameterizedBy(
            targetConcept.nodeWrapperInterfaceType(),
            targetConcept.conceptWrapperInterfaceType(),
        )
    }
}

private fun List<TypeName>.toListLiteralCodeBlock(): CodeBlock {
    val list = this
    return CodeBlock.builder().apply {
        add("return listOf(\n")
        withIndent {
            for (element in list) {
                add("%T,\n", element)
            }
        }
        add(")")
    }.build()
}
