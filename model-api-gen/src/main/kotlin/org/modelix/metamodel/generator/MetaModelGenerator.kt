package org.modelix.metamodel.generator

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import org.modelix.metamodel.*
import org.modelix.model.api.*
import org.modelix.model.data.EnumPropertyType
import org.modelix.model.data.Primitive
import org.modelix.model.data.PrimitivePropertyType
import org.modelix.modelql.core.IFluxStep
import org.modelix.modelql.core.IMonoStep
import org.modelix.modelql.core.IProducingStep
import org.modelix.modelql.typed.TypedModelQL
import java.nio.file.Path
import kotlin.reflect.KClass

class MetaModelGenerator(val outputDir: Path, val nameConfig: NameConfig = NameConfig()) {
    var alwaysUseNonNullableProperties: Boolean = true

    private val headerComment = "\ngenerated by modelix model-api-gen \n"

    private fun ProcessedProperty.asKotlinType(): TypeName {
        val nonNullableType = when (type) {
            is PrimitivePropertyType -> when((type as PrimitivePropertyType).primitive) {
                Primitive.STRING -> String::class.asTypeName()
                Primitive.BOOLEAN -> Boolean::class.asTypeName()
                Primitive.INT -> Int::class.asTypeName()
            }
            is EnumPropertyType -> {
                val enumType = (type as EnumPropertyType)
                ClassName(enumType.pckg, enumType.enumName)
            }
            else -> { throw RuntimeException("Unexpected property type: $type")}
        }
        return if (!optional || alwaysUseNonNullableProperties) nonNullableType else nonNullableType.copy(nullable = true)
    }

    private fun FileSpec.write() {
        writeTo(outputDir)
    }

    private fun ProcessedLanguage.packageDir(): Path {
        val packageName = name
        var packageDir = outputDir
        if (packageName.isNotEmpty()) {
            for (packageComponent in packageName.split('.').dropLastWhile { it.isEmpty() }) {
                packageDir = packageDir.resolve(packageComponent)
            }
        }
        return packageDir
    }

    fun generateRegistrationHelper(classFqName: String, languages: IProcessedLanguageSet) {
        generateRegistrationHelper(classFqName, languages as ProcessedLanguageSet)
    }

    internal fun generateRegistrationHelper(classFqName: String, languages: ProcessedLanguageSet) {
        val typeName = ClassName(classFqName.substringBeforeLast("."), classFqName.substringAfterLast("."))
        val cls = TypeSpec.objectBuilder(typeName)
            .addProperty(PropertySpec.builder("languages", List::class.parameterizedBy(GeneratedLanguage::class))
                .initializer("listOf(" + languages.getLanguages().map { it.generatedClassName() }
                    .joinToString(", ") { it.canonicalName } + ")")
                .build())
            .addFunction(FunSpec.builder("registerAll").addStatement("""languages.forEach { it.register() }""").build())
            .build()

        FileSpec.builder(typeName.packageName, typeName.simpleName)
            .addFileComment(headerComment)
            .addType(cls)
            .build()
            .write()
    }

    fun generate(languages: IProcessedLanguageSet) {
        generate(languages as ProcessedLanguageSet)
    }

    private fun generate(languages: ProcessedLanguageSet) {
        for (language in languages.getLanguages()) {
            language.packageDir().toFile().listFiles()?.filter { it.isFile }?.forEach { it.delete() }
            val builder =
                FileSpec.builder(language.generatedClassName().packageName, language.generatedClassName().simpleName)
            val file = builder.addFileComment(headerComment)
                .addType(generateLanguage(language)).build()
            for (enum in language.getEnums()) {
                generateEnumFile(enum)
            }
            for (concept in language.getConcepts()) {
                generateConceptFile(concept)
                if (concept.getOwnRoles().isNotEmpty()) {
                    generateModelQLFile(concept)
                }
            }
            file.write()
        }
    }

    private fun generateLanguage(language: ProcessedLanguage): TypeSpec {
        val builder = TypeSpec.objectBuilder(language.generatedClassName())
        val conceptNamesList = language.getConcepts()
            .joinToString(", ") { it.name }
        builder.addFunction(
            FunSpec.builder("getConcepts")
                .addModifiers(KModifier.OVERRIDE)
                .addCode(language.getConcepts().map { it.conceptObjectType() }.toListLiteralCodeBlock())
                .build()
        )
        builder.superclass(GeneratedLanguage::class)
        builder.addSuperclassConstructorParameter("\"${language.name}\"")
        for (concept in language.getConcepts()) {
            builder.addProperty(
                PropertySpec.builder(concept.name, concept.conceptWrapperInterfaceType())
                    .initializer("%T", concept.conceptWrapperInterfaceClass())
                    .build()
            )
        }
        return builder.build()
    }

    private fun generateEnumFile(enum: ProcessedEnum) {
        val constructorSpec = FunSpec.constructorBuilder()
            .addParameter("uid", String::class)
            .addParameter("presentation", String::class.asTypeName().copy(nullable = true))
            .build()

        val enumBuilder = TypeSpec.enumBuilder(enum.name)
            .addDeprecationIfNecessary(enum)
            .primaryConstructor(constructorSpec)
            .addSuperinterface(IPropertyValueEnum::class)
            .addProperty(
                PropertySpec.builder("uid", String::class)
                    .initializer("uid")
                    .build()
            )
            .addProperty(
                PropertySpec.builder("presentation", String::class.asTypeName().copy(nullable = true))
                    .initializer("presentation")
                    .addModifiers(KModifier.OVERRIDE)
                    .build()
            )

        val getLiteralFunBuilder = FunSpec.builder("getLiteralByMemberId")
            .addParameter("uid", String::class)
        val getLiteralCodeBuilder = CodeBlock.builder().beginControlFlow("return when (uid) {")

        for (member in enum.getAllMembers()) {
            enumBuilder.addEnumConstant(
                member.name,
                TypeSpec.anonymousClassBuilder()
                    .addSuperclassConstructorParameter("%S", member.uid)
                    .addSuperclassConstructorParameter(
                        if (member.presentation == null) "null" else "%S",
                        member.presentation ?: "")
                    .build()
            )
            getLiteralCodeBuilder.addStatement("%S -> %N", member.uid, member.name)
        }

        getLiteralFunBuilder.addCode(
            getLiteralCodeBuilder
                .addStatement("else -> defaultValue()")
                .endControlFlow()
                .build()
        )

        val companion = TypeSpec.companionObjectBuilder()
            .addFunction(
                FunSpec.builder("defaultValue")
                    .addCode("return values()[%L]", enum.defaultIndex)
                    .build())
            .addFunction(
                getLiteralFunBuilder.build()
            )
            .build()

        val generatedEnum = enumBuilder.addType(companion).build()

        FileSpec.builder(enum.language.name, enum.name)
            .addFileComment(headerComment)
            .addType(generatedEnum)
            .build()
            .write()
    }

    private fun generateConceptFile(concept: ProcessedConcept) {
        FileSpec.builder(concept.language.name, concept.name)
            .addFileComment(headerComment)
            .addType(generateConceptObject(concept))
            .addTypeAlias(TypeAliasSpec.builder(concept.conceptTypeAliasName(), concept.conceptWrapperInterfaceType()).build())
            .addType(generateConceptWrapperInterface(concept))
//            .addType(generateConceptWrapperImpl(concept))
            .addType(generateNodeWrapperInterface(concept))
            .addType(generateNodeWrapperImpl(concept))
            .apply {
                // allow to write `nodes.myChildren` instead of `nodes.flatMap { it.myChildren }`
                for (feature in concept.getOwnRoles()) {
                    val receiverType = Iterable::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType())
                    when (feature) {
                        is ProcessedProperty -> {
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(feature.asKotlinType())
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", feature.generatedName).build()
                                    )
                                    .build()
                            )
                            addProperty(
                                PropertySpec.builder(
                                    "raw_" + feature.generatedName,
                                    List::class.asTypeName()
                                        .parameterizedBy(String::class.asTypeName().copy(nullable = true))
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", "raw_" + feature.generatedName)
                                            .build()
                                    )
                                    .build()
                            )
                        }

                        is ProcessedChildLink -> {
                            val targetType = feature.type.resolved.nodeWrapperInterfaceType()
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(targetType)
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return flatMap { it.%N }", feature.generatedName).build()
                                    )
                                    .build()
                            )
                        }

                        is ProcessedReferenceLink -> {
                            val targetType =
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional)
                            val rawTargetType = INode::class.asTypeName().copy(nullable = true)
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(targetType)
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", feature.generatedName).build()
                                    )
                                    .build()
                            )
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName + "_orNull",
                                    List::class.asTypeName().parameterizedBy(targetType.copy(nullable = true))
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", feature.generatedName + "_orNull").build()
                                    )
                                    .build()
                            )
                            addProperty(
                                PropertySpec.builder(
                                    "raw_" + feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(rawTargetType)
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", "raw_" + feature.generatedName)
                                            .build()
                                    )
                                    .build()
                            )
                        }
                    }
                }
            }
            .build().write()
    }

    private fun generateModelQLFile(concept: ProcessedConcept) {
        FileSpec.builder("org.modelix.modelql.gen." + concept.language.name, concept.name)
            .addFileComment(headerComment)
            .apply {
                for (feature in concept.getOwnRoles()) {
                    val receiverType = Iterable::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType())
                    when (feature) {
                        is ProcessedProperty -> {
                            for (stepType in listOf(IMonoStep::class.asTypeName(), IFluxStep::class.asTypeName())) {
                                val inputType = stepType.parameterizedBy(concept.nodeWrapperInterfaceType())
                                val outputElementType = when (feature.type) {
                                    is EnumPropertyType -> String::class.asTypeName().copy(nullable = true)
                                    is PrimitivePropertyType -> feature.asKotlinType()
                                }
                                val outputType = stepType.parameterizedBy(outputElementType)
                                val functionName = when (val type = feature.type) {
                                    is EnumPropertyType -> "rawProperty"
                                    is PrimitivePropertyType -> when (type.primitive) {
                                        Primitive.STRING -> "stringProperty"
                                        Primitive.BOOLEAN -> "booleanProperty"
                                        Primitive.INT -> "intProperty"
                                    }
                                }
                                addProperty(
                                    PropertySpec.builder(feature.generatedName, outputType)
                                        .receiver(inputType)
                                        .getter(FunSpec.getterBuilder()
                                            .addStatement("return %T.%N(this, %T.%N)",
                                                TypedModelQL::class.asTypeName(),
                                                functionName,
                                                concept.conceptWrapperInterfaceClass(),
                                                feature.generatedName)
                                            .build())
                                        .build()
                                )
                            }

                            addFunction(
                                FunSpec.builder(feature.setterName())
                                    .receiver(
                                        IMonoStep::class.asTypeName()
                                            .parameterizedBy(concept.nodeWrapperInterfaceType())
                                    )
                                    .addParameter("value", IMonoStep::class.asTypeName().parameterizedBy(feature.asKotlinType()))
                                    .addStatement(
                                        "return %T.setProperty(this, %T.%N, value)",
                                        TypedModelQL::class.asTypeName(),
                                        concept.conceptWrapperInterfaceClass(),
                                        feature.generatedName
                                    )
                                    .build()
                            )
                        }

                        is ProcessedChildLink -> {
                            val targetType = feature.type.resolved.nodeWrapperInterfaceType()

                            val inputStepType = (if (feature.multiple) IProducingStep::class else IMonoStep::class).asTypeName()
                            val outputStepType = (if (feature.multiple) IFluxStep::class else IMonoStep::class).asTypeName()
                            val inputType = inputStepType.parameterizedBy(concept.nodeWrapperInterfaceType())
                            val isOptionalSingle = feature.optional && !feature.multiple
                            val outputType = outputStepType.parameterizedBy(
                                targetType.copy(nullable = isOptionalSingle)
                            )
                            addProperty(
                                PropertySpec.builder(feature.generatedName, outputType)
                                    .receiver(inputType)
                                    .getter(FunSpec.getterBuilder()
                                        .addStatement("return %T.children(this, %T.%N)",
                                            TypedModelQL::class.asTypeName(),
                                            concept.conceptWrapperInterfaceClass(),
                                            feature.generatedName)
                                        .build())
                                    .build()
                            )
                        }

                        is ProcessedReferenceLink -> {
                            val targetType =
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional)

                            for (stepType in listOf(IMonoStep::class.asTypeName(), IFluxStep::class.asTypeName())) {
                                val inputType = stepType.parameterizedBy(concept.nodeWrapperInterfaceType())
                                val outputType = stepType.parameterizedBy(targetType.copy(nullable = false))
                                val outputTypeNullable = stepType.parameterizedBy(targetType.copy(nullable = true))
                                addProperty(
                                    PropertySpec.builder(feature.generatedName, outputType)
                                        .receiver(inputType)
                                        .getter(FunSpec.getterBuilder()
                                            .addStatement("return %T.reference(this, %T.%N)",
                                                TypedModelQL::class.asTypeName(),
                                                concept.conceptWrapperInterfaceClass(),
                                                feature.generatedName)
                                            .build())
                                        .build()
                                )
                                addProperty(
                                    PropertySpec.builder(feature.generatedName + "_orNull", outputTypeNullable)
                                        .receiver(inputType)
                                        .getter(FunSpec.getterBuilder()
                                            .addStatement("return %T.referenceOrNull(this, %T.%N)",
                                                TypedModelQL::class.asTypeName(),
                                                concept.conceptWrapperInterfaceClass(),
                                                feature.generatedName)
                                            .build())
                                        .build()
                                )
                            }
                        }
                    }
                }
            }
            .build().write()
    }

    private fun generateConceptObject(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.objectBuilder(concept.conceptObjectName()).apply {
            superclass(
                GeneratedConcept::class.asTypeName().parameterizedBy(
                    concept.nodeWrapperInterfaceType(),
                    concept.conceptWrapperInterfaceType()
                )
            )
            addSuperclassConstructorParameter("%S", concept.name)
            addSuperclassConstructorParameter(concept.abstract.toString())
            val instanceClassType = KClass::class.asClassName().parameterizedBy(concept.nodeWrapperImplType())
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::getInstanceClass.name)
                    .addModifiers(KModifier.OVERRIDE)
                    .addStatement("""return %T::class""", concept.nodeWrapperImplType())
                    .build()
            )
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::typed.name)
                    .addModifiers(KModifier.OVERRIDE)
                    .addStatement("""return %T""", concept.conceptWrapperInterfaceClass())
                    .build()
            )
            addProperty(
                PropertySpec.builder(IConcept::language.name, ILanguage::class, KModifier.OVERRIDE)
                    .initializer(concept.language.generatedClassName().simpleName)
                    .build()
            )
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::wrap.name)
                    .addModifiers(KModifier.OVERRIDE)
                    .addParameter("node", INode::class)
                    .addStatement("return %T(node)", concept.nodeWrapperImplType())
                    .build()
            )
            concept.uid?.let { uid ->
                addFunction(
                    FunSpec.builder(GeneratedConcept<*, *>::getUID.name)
                        .addModifiers(KModifier.OVERRIDE)
                        .addStatement(CodeBlock.of("return %S", uid).toString())
                        .build()
                )
            }
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::getDirectSuperConcepts.name)
                    .addModifiers(KModifier.OVERRIDE)
                    .addCode(
                        concept.getDirectSuperConcepts().map { it.conceptObjectType() }.toList()
                            .toListLiteralCodeBlock()
                    )
                    .returns(List::class.asTypeName().parameterizedBy(IConcept::class.asTypeName()))
                    .build()
            )
            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        val serializer = (if (!feature.optional || alwaysUseNonNullableProperties) {
                            when (feature.type) {
                                is PrimitivePropertyType -> when((feature.type as PrimitivePropertyType).primitive) {
                                    Primitive.STRING -> MandatoryStringPropertySerializer::class
                                    Primitive.BOOLEAN -> MandatoryBooleanPropertySerializer::class
                                    Primitive.INT -> MandatoryIntPropertySerializer::class
                                }
                                is EnumPropertyType -> MandatoryEnumSerializer::class
                                else -> throw RuntimeException("Unexpected property type: ${feature.type}")
                            }
                        } else {
                            when (feature.type) {
                                is PrimitivePropertyType -> when((feature.type as PrimitivePropertyType).primitive) {
                                    Primitive.STRING -> OptionalStringPropertySerializer::class
                                    Primitive.BOOLEAN -> OptionalBooleanPropertySerializer::class
                                    Primitive.INT -> OptionalIntPropertySerializer::class
                                }
                                is EnumPropertyType -> OptionalEnumSerializer::class
                                else -> throw RuntimeException("Unexpected property type: ${feature.type}")
                            }
                        }).asTypeName()

                        val propBuilder = PropertySpec.builder(
                            feature.generatedName,
                            GeneratedProperty::class.asClassName().parameterizedBy(feature.asKotlinType())
                        )
                        if (feature.type is EnumPropertyType) {
                            if (serializer == MandatoryEnumSerializer::class.asTypeName()) {
                                propBuilder.initializer(
                                    """newProperty(%S, %S, %T({ it.uid }, 
                                        |{ if (it != null) %T.getLiteralByMemberId(it) else %T.defaultValue() }), 
                                        |${feature.optional})""".trimMargin(),
                                    feature.originalName,
                                    feature.uid,
                                    serializer,
                                    feature.asKotlinType(),
                                    feature.asKotlinType()
                                )
                            } else {
                                propBuilder.initializer(
                                    """newProperty(%S, %S, %T( { it.uid }, { %T.getLiteralByMemberId(it) }), 
                                        |${feature.optional})""".trimMargin(),
                                    feature.originalName,
                                    feature.uid,
                                    serializer,
                                    feature.asKotlinType()
                                )
                            }
                        } else {
                            propBuilder.initializer(
                                """newProperty(%S, %S, %T, ${feature.optional})""",
                                feature.originalName,
                                feature.uid,
                                serializer
                            )
                        }
                        addProperty(propBuilder.build())
                    }

                    is ProcessedChildLink -> {
                        val methodName = if (feature.multiple) {
                            "newChildListLink"
                        } else {
                            if (feature.optional) {
                                "newOptionalSingleChildLink"
                            } else {
                                "newMandatorySingleChildLink"
                            }
                        }
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.generatedChildLinkType())
                                .initializer(
                                    """$methodName(%S, %S, ${if (feature.multiple) "${feature.optional}, " else ""}%T, %T::class)""",
                                    feature.originalName,
                                    feature.uid,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType()
                                )
                                .build()
                        )
                    }

                    is ProcessedReferenceLink -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.generatedReferenceLinkType())
                                .initializer(
                                    """newReferenceLink(%S, %S, ${feature.optional}, %T, %T::class)""",
                                    feature.originalName,
                                    feature.uid,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType()
                                )
                                .build()
                        )
                    }
                }
            }
        }.build()
    }

    private fun generateConceptWrapperInterface(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.interfaceBuilder(concept.conceptWrapperInterfaceClass()).apply {
            addDeprecationIfNecessary(concept)
            val nodeT = TypeVariableName("NodeT", concept.nodeWrapperInterfaceType(), variance = KModifier.OUT)
            addTypeVariable(nodeT)
            addSuperinterface(IConceptOfTypedNode::class.asTypeName().parameterizedBy(nodeT))
            for (extended in concept.getDirectSuperConcepts()) {
                addSuperinterface(extended.conceptWrapperInterfaceClass().parameterizedBy(nodeT))
            }
            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> addProperty(
                        PropertySpec.builder(
                            feature.generatedName,
                            GeneratedProperty::class.asClassName().parameterizedBy(feature.asKotlinType())
                        )
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .addDeprecationIfNecessary(feature)
                            .build()
                    )

                    is ProcessedChildLink -> addProperty(
                        PropertySpec.builder(feature.generatedName, feature.generatedChildLinkType())
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .addDeprecationIfNecessary(feature)
                            .build()
                    )

                    is ProcessedReferenceLink -> addProperty(
                        PropertySpec.builder(feature.generatedName, feature.generatedReferenceLinkType())
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .addDeprecationIfNecessary(feature)
                            .build()
                    )
                }
            }

            addType(TypeSpec.companionObjectBuilder().apply {
                addSuperinterface(concept.conceptWrapperInterfaceType())
                val t = if (concept.abstract) IConceptOfTypedNode::class else INonAbstractConcept::class
                addSuperinterface(t.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType()))
                addFunction(
                    FunSpec.builder(IConceptOfTypedNode<*>::getInstanceInterface.name)
                        .addModifiers(KModifier.OVERRIDE)
                        .returns(KClass::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType()))
                        .addStatement("return %T::class", concept.nodeWrapperInterfaceType())
                        .build()
                )
                addFunction(
                    FunSpec.builder(ITypedConcept::untyped.name)
                        .returns(IConcept::class)
                        .addModifiers(KModifier.OVERRIDE)
                        .addStatement("return %T", concept.conceptObjectType())
                        .build()
                )
            }.build())
        }.build()
    }

    private fun generateNodeWrapperImpl(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.classBuilder(concept.nodeWrapperImplType()).apply {
            addModifiers(KModifier.OPEN)
            addProperty(
                PropertySpec.builder(
                    TypedNodeImpl::_concept.name,
                    concept.conceptWrapperInterfaceType(),
                    KModifier.OVERRIDE
                )
                    .getter(
                        FunSpec.getterBuilder().addStatement("""return %T""", concept.conceptWrapperInterfaceClass())
                            .build()
                    )
                    .build()
            )

            if (concept.extends.size > 1) {
                // fix kotlin warning about ambiguity in case of multiple inheritance
                addFunction(
                    FunSpec.builder(ITypedNode::unwrap.name)
                        .addModifiers(KModifier.OVERRIDE)
                        .returns(INode::class)
                        .addStatement("return " + TypedNodeImpl::wrappedNode.name)
                        .build()
                )
            }
            primaryConstructor(FunSpec.constructorBuilder().addParameter("_node", INode::class).build())
            if (concept.extends.isEmpty()) {
                superclass(TypedNodeImpl::class)
                addSuperclassConstructorParameter("_node")
            } else {
                superclass(concept.extends.first().resolved.nodeWrapperImplType())
                addSuperclassConstructorParameter("_node")
                for (extended in concept.extends.drop(1)) {
                    addSuperinterface(
                        extended.resolved.nodeWrapperInterfaceType(),
                        CodeBlock.of("%T(_node)", extended.resolved.nodeWrapperImplType())
                    )
                }
            }
            addSuperinterface(concept.nodeWrapperInterfaceType())
            for (feature in concept.getOwnAndDuplicateRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.asKotlinType())
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(unwrap(), %T.%N)""",
                                    TypedPropertyAccessor::class.asTypeName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build()
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                String::class.asTypeName().copy(nullable = true)
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(unwrap(), %T.%N.untyped())""",
                                    RawPropertyAccessor::class.asTypeName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build()
                        )
                    }

                    is ProcessedChildLink -> {
                        // TODO resolve link.type and ensure it exists
                        val accessorSubclass =
                            if (feature.multiple) ChildListAccessor::class else SingleChildAccessor::class
                        val type = accessorSubclass.asClassName()
                            .parameterizedBy(
                                feature.type.resolved.nodeWrapperInterfaceType()
                            )
                        addProperty(
                            PropertySpec.builder(feature.generatedName, type)
                                .addModifiers(KModifier.OVERRIDE)
                                .initializer(
                                    """%T(%N(), %T.%N, %T, %T::class)""",
                                    accessorSubclass.asTypeName(),
                                    ITypedNode::unwrap.name,
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType()
                                )
                                .build()
                        )
                    }

                    is ProcessedReferenceLink -> {
                        val accessorClass =
                            if (feature.optional) OptionalReferenceAccessor::class else MandatoryReferenceAccessor::class
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName,
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional)
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(%N(), %T.%N, %T::class)""",
                                    accessorClass.asTypeName(),
                                    ITypedNode::unwrap.name,
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                    feature.type.resolved.nodeWrapperInterfaceType()
                                )
                                .build()
                        )
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName + "_orNull",
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = true)
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(false)
                                .delegate(
                                    """%T(%N(), %T.%N, %T::class)""",
                                    OptionalReferenceAccessor::class.asTypeName(),
                                    ITypedNode::unwrap.name,
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                    feature.type.resolved.nodeWrapperInterfaceType()
                                )
                                .build()
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                INode::class.asTypeName().copy(nullable = true)
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(${ITypedNode::unwrap.name}(), %T.%N)""",
                                    RawReferenceAccessor::class.asClassName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build()
                        )
                    }
                }
            }
        }.build()
    }

    private fun generateNodeWrapperInterface(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.interfaceBuilder(concept.nodeWrapperInterfaceType()).apply {
            addDeprecationIfNecessary(concept)
            if (concept.extends.isEmpty()) addSuperinterface(ITypedNode::class.asTypeName())
            for (extended in concept.extends) {
                addSuperinterface(extended.resolved.nodeWrapperInterfaceType())
            }
            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.asKotlinType())
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build()
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                String::class.asTypeName().copy(nullable = true)
                            )
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build()
                        )
                    }

                    is ProcessedChildLink -> {
                        // TODO resolve link.type and ensure it exists
                        val accessorSubclass =
                            if (feature.multiple) ChildListAccessor::class else SingleChildAccessor::class
                        val type = accessorSubclass.asClassName()
                            .parameterizedBy(
                                feature.type.resolved.nodeWrapperInterfaceType()
                            )
                        addProperty(
                            PropertySpec.builder(feature.generatedName, type)
                                .addDeprecationIfNecessary(feature)
                                .build()
                        )
                    }

                    is ProcessedReferenceLink -> {
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName,
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional)
                            )
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build()
                        )
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName + "_orNull",
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = true)
                            )
                                .mutable(false)
                                .build()
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                INode::class.asTypeName().copy(nullable = true)
                            )
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build()
                        )
                    }
                }
            }
        }.build()
    }

    private fun generateDeprecationAnnotation(message: String): AnnotationSpec {
        val annotationBuilder = AnnotationSpec.builder(Deprecated::class)
        if (message.isNotEmpty()) { annotationBuilder.addMember("message = %S", message) }
        return annotationBuilder.build()
    }

    private fun TypeSpec.Builder.addDeprecationIfNecessary(deprecatable: IProcessedDeprecatable) : TypeSpec.Builder {
        return deprecatable.deprecationMessage?.let { addAnnotation(generateDeprecationAnnotation(it)) } ?: this
    }

    private fun PropertySpec.Builder.addDeprecationIfNecessary(deprecatable: IProcessedDeprecatable) : PropertySpec.Builder {
        return deprecatable.deprecationMessage?.let { addAnnotation(generateDeprecationAnnotation(it)) } ?: this
    }

    private fun ProcessedConcept.conceptWrapperInterfaceType() =
        conceptWrapperInterfaceClass().parameterizedBy(nodeWrapperInterfaceType())

    private fun ProcessedConcept.conceptWrapperInterfaceClass() =
        ClassName(language.name, nameConfig.typedConcept(name))

    private fun ProcessedLanguage.generatedClassName() = ClassName(name, nameConfig.languageClass(name))
    private fun ProcessedConcept.nodeWrapperInterfaceName() = nameConfig.typedNode(name)
    private fun ProcessedConcept.nodeWrapperImplName() = nameConfig.typedNodeImpl(name)
    private fun ProcessedConcept.conceptObjectName() = nameConfig.untypedConcept(name)
    private fun ProcessedConcept.conceptTypeAliasName() = nameConfig.conceptTypeAlias(name)
    //private fun ProcessedConcept.conceptWrapperImplName() = nameConfig.conceptWrapperImplName(name)
    //private fun ProcessedConcept.conceptWrapperInterfaceName() = nameConfig.conceptWrapperInterfaceName(name)

    //private fun ProcessedConcept.getConceptFqName() = language.name + "." + name
    private fun ProcessedConcept.conceptObjectType() = ClassName(language.name, conceptObjectName())
    private fun ProcessedConcept.nodeWrapperImplType() = ClassName(language.name, nodeWrapperImplName())
    private fun ProcessedConcept.nodeWrapperInterfaceType() = ClassName(language.name, nodeWrapperInterfaceName())

    //private fun ProcessedRole.kotlinRef() = CodeBlock.of("%T.%N", concept.conceptObjectType(), generatedName)
    private fun ProcessedRole.returnKotlinRef() =
        CodeBlock.of("return %T.%N", concept.conceptObjectType(), generatedName)

    private fun ProcessedChildLink.generatedChildLinkType(): TypeName {
        val childConcept = type.resolved
        val linkClass = if (multiple) {
            GeneratedChildListLink::class
        } else {
            if (optional) GeneratedSingleChildLink::class else GeneratedMandatorySingleChildLink::class
        }
        return linkClass.asClassName().parameterizedBy(
            childConcept.nodeWrapperInterfaceType(), childConcept.conceptWrapperInterfaceType()
        )
    }

    private fun ProcessedReferenceLink.generatedReferenceLinkType(): TypeName {
        val targetConcept = type.resolved
        return GeneratedReferenceLink::class.asClassName().parameterizedBy(
            targetConcept.nodeWrapperInterfaceType(), targetConcept.conceptWrapperInterfaceType()
        )
    }
}

private fun List<TypeName>.toListLiteralCodeBlock(): CodeBlock {
    val list = this
    return CodeBlock.builder().apply {
        add("return listOf(\n")
        withIndent {
            for (element in list) {
                add("%T,\n", element)
            }
        }
        add(")")
    }.build()
}