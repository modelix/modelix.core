package org.modelix.metamodel.generator

import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeAliasSpec
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.TypeVariableName
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.withIndent
import org.modelix.metamodel.ChildListAccessor
import org.modelix.metamodel.GeneratedChildListLink
import org.modelix.metamodel.GeneratedConcept
import org.modelix.metamodel.GeneratedLanguage
import org.modelix.metamodel.GeneratedMandatorySingleChildLink
import org.modelix.metamodel.GeneratedProperty
import org.modelix.metamodel.GeneratedReferenceLink
import org.modelix.metamodel.GeneratedSingleChildLink
import org.modelix.metamodel.IConceptOfTypedNode
import org.modelix.metamodel.INonAbstractConcept
import org.modelix.metamodel.ITypedConcept
import org.modelix.metamodel.ITypedNode
import org.modelix.metamodel.MandatoryBooleanPropertySerializer
import org.modelix.metamodel.MandatoryEnumSerializer
import org.modelix.metamodel.MandatoryIntPropertySerializer
import org.modelix.metamodel.MandatoryReferenceAccessor
import org.modelix.metamodel.MandatoryStringPropertySerializer
import org.modelix.metamodel.OptionalBooleanPropertySerializer
import org.modelix.metamodel.OptionalEnumSerializer
import org.modelix.metamodel.OptionalIntPropertySerializer
import org.modelix.metamodel.OptionalReferenceAccessor
import org.modelix.metamodel.OptionalStringPropertySerializer
import org.modelix.metamodel.RawPropertyAccessor
import org.modelix.metamodel.RawReferenceAccessor
import org.modelix.metamodel.SingleChildAccessor
import org.modelix.metamodel.TypedNodeImpl
import org.modelix.metamodel.TypedPropertyAccessor
import org.modelix.model.api.IConcept
import org.modelix.model.api.ILanguage
import org.modelix.model.api.INode
import org.modelix.model.data.EnumPropertyType
import org.modelix.model.data.Primitive
import org.modelix.model.data.PrimitivePropertyType
import org.modelix.modelql.core.IFluxStep
import org.modelix.modelql.core.IMonoStep
import org.modelix.modelql.core.IProducingStep
import org.modelix.modelql.typed.TypedModelQL
import java.nio.file.Path
import kotlin.reflect.KClass

class MetaModelGenerator(
    val outputDir: Path,
    val nameConfig: NameConfig = NameConfig(),
    val modelqlOutputDir: Path? = null,
    val conceptPropertiesInterfaceName: String? = null,
) {
    var alwaysUseNonNullableProperties: Boolean = true

    companion object {
        const val HEADER_COMMENT = "\ngenerated by modelix model-api-gen \n"
    }

    private fun ProcessedProperty.asKotlinType(): TypeName {
        val nonNullableType = when (type) {
            is PrimitivePropertyType -> when ((type as PrimitivePropertyType).primitive) {
                Primitive.STRING -> String::class.asTypeName()
                Primitive.BOOLEAN -> Boolean::class.asTypeName()
                Primitive.INT -> Int::class.asTypeName()
            }
            is EnumPropertyType -> {
                val enumType = (type as EnumPropertyType)
                ClassName(enumType.pckg, enumType.enumName)
            }
            else -> { throw RuntimeException("Unexpected property type: $type") }
        }
        return if (!optional || alwaysUseNonNullableProperties) nonNullableType else nonNullableType.copy(nullable = true)
    }

    private fun FileSpec.write() {
        writeTo(outputDir)
    }

    private fun ProcessedLanguage.packageDir(): Path {
        val packageName = name
        var packageDir = outputDir
        if (packageName.isNotEmpty()) {
            for (packageComponent in packageName.split('.').dropLastWhile { it.isEmpty() }) {
                packageDir = packageDir.resolve(packageComponent)
            }
        }
        return packageDir
    }

    fun generateRegistrationHelper(classFqName: String, languages: IProcessedLanguageSet) {
        RegistrationHelperGenerator(classFqName, languages as ProcessedLanguageSet, this).generateFile()
    }

    private fun generateConceptMetaPropertiesInterface(languages: IProcessedLanguageSet) {
        val fqName = checkNotNull(conceptPropertiesInterfaceName)
        require(fqName.contains(".")) { "The name of the concept properties interface does not contain a dot. Use a fully qualified name." }
        val interfaceName = ClassName(fqName.substringBeforeLast("."), fqName.substringAfterLast("."))
        val metaPropertiesInterface = TypeSpec.interfaceBuilder(interfaceName)
            .generateMetaProperties(languages as ProcessedLanguageSet)
            .build()

        FileSpec.builder(interfaceName.packageName, interfaceName.simpleName)
            .addFileComment(HEADER_COMMENT)
            .addType(metaPropertiesInterface)
            .build()
            .write()
    }

    private fun TypeSpec.Builder.generateMetaProperties(languages: ProcessedLanguageSet): TypeSpec.Builder {
        val nullGetter = FunSpec.getterBuilder().addCode("return null").build()
        languages.getConceptMetaProperties().forEach {
            addProperty(
                PropertySpec.builder(it, String::class.asTypeName().copy(nullable = true))
                    .getter(nullGetter)
                    .build(),
            )
        }
        return this
    }

    fun generate(languages: IProcessedLanguageSet) {
        generate(languages as ProcessedLanguageSet)
    }

    private fun generate(languages: ProcessedLanguageSet) {
        if (conceptPropertiesInterfaceName != null) {
            generateConceptMetaPropertiesInterface(languages)
        }

        for (language in languages.getLanguages()) {
            language.packageDir().toFile().listFiles()?.filter { it.isFile }?.forEach { it.delete() }
            val builder =
                FileSpec.builder(language.generatedClassName().packageName, language.generatedClassName().simpleName)
            val file = builder.addFileComment(HEADER_COMMENT)
                .addType(generateLanguage(language)).build()
            file.write()

            for (enum in language.getEnums()) {
                EnumFileGenerator(enum, outputDir).generateFile()
            }

            for (concept in language.getConcepts()) {
                generateConceptFile(concept)
                if (modelqlOutputDir != null && concept.getOwnRoles().isNotEmpty()) {
                    generateModelQLFile(concept)
                }
            }
        }
    }

    private fun generateLanguage(language: ProcessedLanguage): TypeSpec {
        val builder = TypeSpec.objectBuilder(language.generatedClassName())
        val conceptNamesList = language.getConcepts()
            .joinToString(", ") { it.name }
        builder.addFunction(
            FunSpec.builder("getConcepts")
                .returns(List::class.asClassName().parameterizedBy(IConcept::class.asTypeName()))
                .addModifiers(KModifier.OVERRIDE)
                .addCode(language.getConcepts().map { it.conceptObjectType() }.toListLiteralCodeBlock())
                .build(),
        )
        builder.superclass(GeneratedLanguage::class)
        builder.addSuperclassConstructorParameter("\"${language.name}\"")
        for (concept in language.getConcepts()) {
            builder.addProperty(
                PropertySpec.builder(concept.name, concept.conceptWrapperInterfaceType())
                    .initializer("%T", concept.conceptWrapperInterfaceClass())
                    .build(),
            )
        }
        return builder.build()
    }

    private fun generateConceptFile(concept: ProcessedConcept) {
        FileSpec.builder(concept.language.name, concept.name)
            .addFileComment(HEADER_COMMENT)
            .addType(generateConceptObject(concept))
            .addTypeAlias(TypeAliasSpec.builder(concept.conceptTypeAliasName(), concept.conceptWrapperInterfaceType()).build())
            .addType(generateConceptWrapperInterface(concept))
//            .addType(generateConceptWrapperImpl(concept))
            .addType(generateNodeWrapperInterface(concept))
            .addType(generateNodeWrapperImpl(concept))
            .apply {
                // allow to write `nodes.myChildren` instead of `nodes.flatMap { it.myChildren }`
                for (feature in concept.getOwnRoles()) {
                    val receiverType = Iterable::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType())
                    when (feature) {
                        is ProcessedProperty -> {
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(feature.asKotlinType()),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", feature.generatedName).build(),
                                    )
                                    .build(),
                            )
                            addProperty(
                                PropertySpec.builder(
                                    "raw_" + feature.generatedName,
                                    List::class.asTypeName()
                                        .parameterizedBy(String::class.asTypeName().copy(nullable = true)),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", "raw_" + feature.generatedName)
                                            .build(),
                                    )
                                    .build(),
                            )
                        }

                        is ProcessedChildLink -> {
                            val targetType = feature.type.resolved.nodeWrapperInterfaceType()
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(targetType),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return flatMap { it.%N }", feature.generatedName).build(),
                                    )
                                    .build(),
                            )
                        }

                        is ProcessedReferenceLink -> {
                            val targetType =
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional)
                            val rawTargetType = INode::class.asTypeName().copy(nullable = true)
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(targetType),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", feature.generatedName).build(),
                                    )
                                    .build(),
                            )
                            addProperty(
                                PropertySpec.builder(
                                    feature.generatedName + "_orNull",
                                    List::class.asTypeName().parameterizedBy(targetType.copy(nullable = true)),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", feature.generatedName + "_orNull").build(),
                                    )
                                    .build(),
                            )
                            addProperty(
                                PropertySpec.builder(
                                    "raw_" + feature.generatedName,
                                    List::class.asTypeName().parameterizedBy(rawTargetType),
                                )
                                    .receiver(receiverType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement("return map { it.%N }", "raw_" + feature.generatedName)
                                            .build(),
                                    )
                                    .build(),
                            )
                        }
                    }
                }
            }
            .build().write()
    }

    private fun generateModelQLFile(concept: ProcessedConcept) {
        FileSpec.builder("org.modelix.modelql.gen." + concept.language.name, concept.name)
            .addFileComment(HEADER_COMMENT)
            .apply {
                for (feature in concept.getOwnRoles()) {
                    val receiverType = Iterable::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType())
                    when (feature) {
                        is ProcessedProperty -> {
                            for (stepType in listOf(IMonoStep::class.asTypeName(), IFluxStep::class.asTypeName())) {
                                val inputType = stepType.parameterizedBy(concept.nodeWrapperInterfaceType())
                                val outputElementType = when (feature.type) {
                                    is EnumPropertyType -> String::class.asTypeName().copy(nullable = true)
                                    is PrimitivePropertyType -> feature.asKotlinType()
                                }
                                val outputType = stepType.parameterizedBy(outputElementType)
                                val functionName = when (val type = feature.type) {
                                    is EnumPropertyType -> "rawProperty"
                                    is PrimitivePropertyType -> when (type.primitive) {
                                        Primitive.STRING -> "stringProperty"
                                        Primitive.BOOLEAN -> "booleanProperty"
                                        Primitive.INT -> "intProperty"
                                    }
                                }
                                addProperty(
                                    PropertySpec.builder(feature.generatedName, outputType)
                                        .receiver(inputType)
                                        .getter(
                                            FunSpec.getterBuilder()
                                                .addStatement(
                                                    "return %T.%N(this, %T.%N)",
                                                    TypedModelQL::class.asTypeName(),
                                                    functionName,
                                                    concept.conceptWrapperInterfaceClass(),
                                                    feature.generatedName,
                                                )
                                                .build(),
                                        )
                                        .build(),
                                )
                            }

                            val inputStepType = IMonoStep::class.asTypeName()
                                .parameterizedBy(concept.nodeWrapperInterfaceType())
                            addFunction(
                                FunSpec.builder(feature.setterName())
                                    .returns(inputStepType)
                                    .receiver(inputStepType)
                                    .addParameter("value", IMonoStep::class.asTypeName().parameterizedBy(feature.asKotlinType()))
                                    .addStatement(
                                        "return %T.setProperty(this, %T.%N, value)",
                                        TypedModelQL::class.asTypeName(),
                                        concept.conceptWrapperInterfaceClass(),
                                        feature.generatedName,
                                    )
                                    .build(),
                            )
                        }

                        is ProcessedChildLink -> {
                            val targetType = feature.type.resolved.nodeWrapperInterfaceType()

                            val inputStepType = (if (feature.multiple) IProducingStep::class else IMonoStep::class).asTypeName()
                            val outputStepType = (if (feature.multiple) IFluxStep::class else IMonoStep::class).asTypeName()
                            val inputType = inputStepType.parameterizedBy(concept.nodeWrapperInterfaceType())
                            val isOptionalSingle = feature.optional && !feature.multiple
                            val outputType = outputStepType.parameterizedBy(
                                targetType.copy(nullable = isOptionalSingle),
                            )
                            addProperty(
                                PropertySpec.builder(feature.generatedName, outputType)
                                    .receiver(inputType)
                                    .getter(
                                        FunSpec.getterBuilder()
                                            .addStatement(
                                                "return %T.children(this, %T.%N)",
                                                TypedModelQL::class.asTypeName(),
                                                concept.conceptWrapperInterfaceClass(),
                                                feature.generatedName,
                                            )
                                            .build(),
                                    )
                                    .build(),
                            )
                            val returnType = IMonoStep::class.asTypeName().parameterizedBy(targetType)
                            val receiverType = IMonoStep::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType())
                            val conceptParameter = ParameterSpec.builder("concept", ITypedConcept::class.asTypeName()).apply {
                                if (!feature.type.resolved.abstract) {
                                    defaultValue("%T", feature.type.resolved.conceptWrapperInterfaceClass())
                                }
                            }.build()

                            if (feature.multiple) {
                                addFunction(
                                    FunSpec.builder(feature.adderMethodName())
                                        .returns(returnType)
                                        .receiver(receiverType)
                                        .addParameter(conceptParameter)
                                        .addParameter(
                                            ParameterSpec.builder("index", Int::class.asTypeName())
                                                .defaultValue("-1")
                                                .build(),
                                        )
                                        .addStatement(
                                            "return %T.addNewChild(this, %T.%N, index, concept)",
                                            TypedModelQL::class.asTypeName(),
                                            concept.conceptObjectType(),
                                            feature.generatedName,
                                        )
                                        .build(),
                                )
                            } else {
                                addFunction(
                                    FunSpec.builder(feature.setterName())
                                        .returns(returnType)
                                        .receiver(receiverType)
                                        .addParameter(conceptParameter)
                                        .addStatement(
                                            "return %T.setChild(this, %T.%N, concept)",
                                            TypedModelQL::class.asTypeName(),
                                            concept.conceptObjectType(),
                                            feature.generatedName,
                                        )
                                        .build(),
                                )
                            }
                        }

                        is ProcessedReferenceLink -> {
                            val targetType =
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional)

                            for (stepType in listOf(IMonoStep::class.asTypeName(), IFluxStep::class.asTypeName())) {
                                val inputType = stepType.parameterizedBy(concept.nodeWrapperInterfaceType())
                                val outputType = stepType.parameterizedBy(targetType.copy(nullable = false))
                                val outputTypeNullable = stepType.parameterizedBy(targetType.copy(nullable = true))
                                addProperty(
                                    PropertySpec.builder(feature.generatedName, outputType)
                                        .receiver(inputType)
                                        .getter(
                                            FunSpec.getterBuilder()
                                                .addStatement(
                                                    "return %T.reference(this, %T.%N)",
                                                    TypedModelQL::class.asTypeName(),
                                                    concept.conceptWrapperInterfaceClass(),
                                                    feature.generatedName,
                                                )
                                                .build(),
                                        )
                                        .build(),
                                )
                                addProperty(
                                    PropertySpec.builder(feature.generatedName + "_orNull", outputTypeNullable)
                                        .receiver(inputType)
                                        .getter(
                                            FunSpec.getterBuilder()
                                                .addStatement(
                                                    "return %T.referenceOrNull(this, %T.%N)",
                                                    TypedModelQL::class.asTypeName(),
                                                    concept.conceptWrapperInterfaceClass(),
                                                    feature.generatedName,
                                                )
                                                .build(),
                                        )
                                        .build(),
                                )
                            }

                            val inputStepType = IMonoStep::class.asTypeName()
                                .parameterizedBy(concept.nodeWrapperInterfaceType())
                            addFunction(
                                FunSpec.builder(feature.setterName())
                                    .returns(inputStepType)
                                    .receiver(inputStepType)
                                    .addParameter(
                                        "target",
                                        IMonoStep::class.asTypeName().parameterizedBy(targetType)
                                            .let { if (feature.optional) it.copy(nullable = true) else it },
                                    )
                                    .addStatement(
                                        "return %T.setReference(this, %T.%N, target)",
                                        TypedModelQL::class.asTypeName(),
                                        concept.conceptWrapperInterfaceClass(),
                                        feature.generatedName,
                                    )
                                    .build(),
                            )
                        }
                    }
                }
            }
            .build().writeTo(modelqlOutputDir!!)
    }

    private fun generateConceptObject(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.objectBuilder(concept.conceptObjectName()).apply {
            superclass(
                GeneratedConcept::class.asTypeName().parameterizedBy(
                    concept.nodeWrapperInterfaceType(),
                    concept.conceptWrapperInterfaceType(),
                ),
            )
            addSuperclassConstructorParameter("%S", concept.name)
            addSuperclassConstructorParameter(concept.abstract.toString())
            val instanceClassType = KClass::class.asClassName().parameterizedBy(concept.nodeWrapperImplType())
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::getInstanceClass.name)
                    .returns(KClass::class.asClassName().parameterizedBy(concept.nodeWrapperImplType()))
                    .addModifiers(KModifier.OVERRIDE)
                    .addStatement("""return %T::class""", concept.nodeWrapperImplType())
                    .build(),
            )
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::typed.name)
                    .returns(concept.conceptWrapperInterfaceType())
                    .addModifiers(KModifier.OVERRIDE)
                    .addStatement("""return %T""", concept.conceptWrapperInterfaceClass())
                    .build(),
            )
            addProperty(
                PropertySpec.builder(IConcept::language.name, ILanguage::class, KModifier.OVERRIDE)
                    .initializer(concept.language.generatedClassName().simpleName)
                    .build(),
            )
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::wrap.name)
                    .returns(concept.nodeWrapperImplType())
                    .addModifiers(KModifier.OVERRIDE)
                    .addParameter("node", INode::class)
                    .addStatement("return %T(node)", concept.nodeWrapperImplType())
                    .build(),
            )
            concept.uid?.let { uid ->
                addFunction(
                    FunSpec.builder(GeneratedConcept<*, *>::getUID.name)
                        .returns(String::class)
                        .addModifiers(KModifier.OVERRIDE)
                        .addStatement(CodeBlock.of("return %S", uid).toString())
                        .build(),
                )
            }
            addFunction(
                FunSpec.builder(GeneratedConcept<*, *>::getDirectSuperConcepts.name)
                    .addModifiers(KModifier.OVERRIDE)
                    .addCode(
                        concept.getDirectSuperConcepts().map { it.conceptObjectType() }.toList()
                            .toListLiteralCodeBlock(),
                    )
                    .returns(List::class.asTypeName().parameterizedBy(IConcept::class.asTypeName()))
                    .build(),
            )
            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        val serializer = (
                            if (!feature.optional || alwaysUseNonNullableProperties) {
                                when (feature.type) {
                                    is PrimitivePropertyType -> when ((feature.type as PrimitivePropertyType).primitive) {
                                        Primitive.STRING -> MandatoryStringPropertySerializer::class
                                        Primitive.BOOLEAN -> MandatoryBooleanPropertySerializer::class
                                        Primitive.INT -> MandatoryIntPropertySerializer::class
                                    }
                                    is EnumPropertyType -> MandatoryEnumSerializer::class
                                    else -> throw RuntimeException("Unexpected property type: ${feature.type}")
                                }
                            } else {
                                when (feature.type) {
                                    is PrimitivePropertyType -> when ((feature.type as PrimitivePropertyType).primitive) {
                                        Primitive.STRING -> OptionalStringPropertySerializer::class
                                        Primitive.BOOLEAN -> OptionalBooleanPropertySerializer::class
                                        Primitive.INT -> OptionalIntPropertySerializer::class
                                    }
                                    is EnumPropertyType -> OptionalEnumSerializer::class
                                    else -> throw RuntimeException("Unexpected property type: ${feature.type}")
                                }
                            }
                            ).asTypeName()

                        val propBuilder = PropertySpec.builder(
                            feature.generatedName,
                            GeneratedProperty::class.asClassName().parameterizedBy(feature.asKotlinType()),
                        )
                        if (feature.type is EnumPropertyType) {
                            if (serializer == MandatoryEnumSerializer::class.asTypeName()) {
                                propBuilder.initializer(
                                    """newProperty(%S, %S, %T({ it.uid },
                                        |{ if (it != null) %T.getLiteralByMemberId(it) else %T.defaultValue() }),
                                        |${feature.optional})
                                    """.trimMargin(),
                                    feature.originalName,
                                    feature.uid,
                                    serializer,
                                    feature.asKotlinType(),
                                    feature.asKotlinType(),
                                )
                            } else {
                                propBuilder.initializer(
                                    """newProperty(%S, %S, %T( { it.uid }, { %T.getLiteralByMemberId(it) }),
                                        |${feature.optional})
                                    """.trimMargin(),
                                    feature.originalName,
                                    feature.uid,
                                    serializer,
                                    feature.asKotlinType(),
                                )
                            }
                        } else {
                            propBuilder.initializer(
                                """newProperty(%S, %S, %T, ${feature.optional})""",
                                feature.originalName,
                                feature.uid,
                                serializer,
                            )
                        }
                        addProperty(propBuilder.build())
                    }

                    is ProcessedChildLink -> {
                        val methodName = if (feature.multiple) {
                            "newChildListLink"
                        } else {
                            if (feature.optional) {
                                "newOptionalSingleChildLink"
                            } else {
                                "newMandatorySingleChildLink"
                            }
                        }
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.generatedChildLinkType())
                                .initializer(
                                    """$methodName(%S, %S, ${if (feature.multiple) "${feature.optional}, " else ""}%T, %T::class)""",
                                    feature.originalName,
                                    feature.uid,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType(),
                                )
                                .build(),
                        )
                    }

                    is ProcessedReferenceLink -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.generatedReferenceLinkType())
                                .initializer(
                                    """newReferenceLink(%S, %S, ${feature.optional}, %T, %T::class)""",
                                    feature.originalName,
                                    feature.uid,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType(),
                                )
                                .build(),
                        )
                    }
                }
            }
        }.build()
    }

    private fun generateConceptWrapperInterface(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.interfaceBuilder(concept.conceptWrapperInterfaceClass()).apply {
            addDeprecationIfNecessary(concept)
            val nodeT = TypeVariableName("NodeT", concept.nodeWrapperInterfaceType(), variance = KModifier.OUT)
            addTypeVariable(nodeT)
            addSuperinterface(IConceptOfTypedNode::class.asTypeName().parameterizedBy(nodeT))
            for (extended in concept.getDirectSuperConcepts()) {
                addSuperinterface(extended.conceptWrapperInterfaceClass().parameterizedBy(nodeT))
            }

            if (conceptPropertiesInterfaceName != null && concept.extends.isEmpty()) {
                val pckgName = conceptPropertiesInterfaceName.substringBeforeLast(".")
                val interfaceName = conceptPropertiesInterfaceName.substringAfterLast(".")
                addSuperinterface(ClassName(pckgName, interfaceName))
            }

            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> addProperty(
                        PropertySpec.builder(
                            feature.generatedName,
                            GeneratedProperty::class.asClassName().parameterizedBy(feature.asKotlinType()),
                        )
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .addDeprecationIfNecessary(feature)
                            .build(),
                    )

                    is ProcessedChildLink -> addProperty(
                        PropertySpec.builder(feature.generatedName, feature.generatedChildLinkType())
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .addDeprecationIfNecessary(feature)
                            .build(),
                    )

                    is ProcessedReferenceLink -> addProperty(
                        PropertySpec.builder(feature.generatedName, feature.generatedReferenceLinkType())
                            .getter(FunSpec.getterBuilder().addCode(feature.returnKotlinRef()).build())
                            .addDeprecationIfNecessary(feature)
                            .build(),
                    )
                }
            }

            addType(
                TypeSpec.companionObjectBuilder().apply {
                    addSuperinterface(concept.conceptWrapperInterfaceType())
                    val t = if (concept.abstract) IConceptOfTypedNode::class else INonAbstractConcept::class
                    addSuperinterface(t.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType()))
                    addFunction(
                        FunSpec.builder(IConceptOfTypedNode<*>::getInstanceInterface.name)
                            .addModifiers(KModifier.OVERRIDE)
                            .returns(KClass::class.asTypeName().parameterizedBy(concept.nodeWrapperInterfaceType()))
                            .addStatement("return %T::class", concept.nodeWrapperInterfaceType())
                            .build(),
                    )
                    addFunction(
                        FunSpec.builder(ITypedConcept::untyped.name)
                            .returns(IConcept::class)
                            .addModifiers(KModifier.OVERRIDE)
                            .addStatement("return %T", concept.conceptObjectType())
                            .build(),
                    )
                    if (conceptPropertiesInterfaceName != null) {
                        concept.metaProperties.forEach { (key, value) ->
                            addProperty(
                                PropertySpec.builder(key, String::class.asTypeName())
                                    .addModifiers(KModifier.OVERRIDE)
                                    .initializer("%S", value)
                                    .build(),
                            )
                        }
                    }
                }.build(),
            )
        }.build()
    }

    private fun generateNodeWrapperImpl(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.classBuilder(concept.nodeWrapperImplType()).apply {
            addModifiers(KModifier.OPEN)
            addProperty(
                PropertySpec.builder(
                    TypedNodeImpl::_concept.name,
                    concept.conceptWrapperInterfaceType(),
                    KModifier.OVERRIDE,
                )
                    .getter(
                        FunSpec.getterBuilder().addStatement("""return %T""", concept.conceptWrapperInterfaceClass())
                            .build(),
                    )
                    .build(),
            )

            if (concept.extends.size > 1) {
                // fix kotlin warning about ambiguity in case of multiple inheritance
                addFunction(
                    FunSpec.builder(ITypedNode::unwrap.name)
                        .addModifiers(KModifier.OVERRIDE)
                        .returns(INode::class)
                        .addStatement("return " + TypedNodeImpl::wrappedNode.name)
                        .build(),
                )
            }
            primaryConstructor(FunSpec.constructorBuilder().addParameter("_node", INode::class).build())
            if (concept.extends.isEmpty()) {
                superclass(TypedNodeImpl::class)
                addSuperclassConstructorParameter("_node")
            } else {
                superclass(concept.extends.first().resolved.nodeWrapperImplType())
                addSuperclassConstructorParameter("_node")
                for (extended in concept.extends.drop(1)) {
                    addSuperinterface(
                        extended.resolved.nodeWrapperInterfaceType(),
                        CodeBlock.of("%T(_node)", extended.resolved.nodeWrapperImplType()),
                    )
                }
            }
            addSuperinterface(concept.nodeWrapperInterfaceType())
            for (feature in concept.getOwnAndDuplicateRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.asKotlinType())
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(unwrap(), %T.%N)""",
                                    TypedPropertyAccessor::class.asTypeName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                String::class.asTypeName().copy(nullable = true),
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(unwrap(), %T.%N.untyped())""",
                                    RawPropertyAccessor::class.asTypeName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build(),
                        )
                    }

                    is ProcessedChildLink -> {
                        // TODO resolve link.type and ensure it exists
                        val accessorSubclass =
                            if (feature.multiple) ChildListAccessor::class else SingleChildAccessor::class
                        val type = accessorSubclass.asClassName()
                            .parameterizedBy(
                                feature.type.resolved.nodeWrapperInterfaceType(),
                            )
                        addProperty(
                            PropertySpec.builder(feature.generatedName, type)
                                .addModifiers(KModifier.OVERRIDE)
                                .initializer(
                                    """%T(%N(), %T.%N, %T, %T::class)""",
                                    accessorSubclass.asTypeName(),
                                    ITypedNode::unwrap.name,
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                    feature.type.resolved.conceptObjectType(),
                                    feature.type.resolved.nodeWrapperInterfaceType(),
                                )
                                .build(),
                        )
                    }

                    is ProcessedReferenceLink -> {
                        val accessorClass =
                            if (feature.optional) OptionalReferenceAccessor::class else MandatoryReferenceAccessor::class
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName,
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional),
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(%N(), %T.%N, %T::class)""",
                                    accessorClass.asTypeName(),
                                    ITypedNode::unwrap.name,
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                    feature.type.resolved.nodeWrapperInterfaceType(),
                                )
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName + "_orNull",
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = true),
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(false)
                                .delegate(
                                    """%T(%N(), %T.%N, %T::class)""",
                                    OptionalReferenceAccessor::class.asTypeName(),
                                    ITypedNode::unwrap.name,
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                    feature.type.resolved.nodeWrapperInterfaceType(),
                                )
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                INode::class.asTypeName().copy(nullable = true),
                            )
                                .addModifiers(KModifier.OVERRIDE)
                                .mutable(true)
                                .delegate(
                                    """%T(${ITypedNode::unwrap.name}(), %T.%N)""",
                                    RawReferenceAccessor::class.asClassName(),
                                    feature.concept.conceptObjectType(),
                                    feature.generatedName,
                                )
                                .build(),
                        )
                    }
                }
            }
        }.build()
    }

    private fun generateNodeWrapperInterface(concept: ProcessedConcept): TypeSpec {
        return TypeSpec.interfaceBuilder(concept.nodeWrapperInterfaceType()).apply {
            addDeprecationIfNecessary(concept)
            if (concept.extends.isEmpty()) addSuperinterface(ITypedNode::class.asTypeName())
            for (extended in concept.extends) {
                addSuperinterface(extended.resolved.nodeWrapperInterfaceType())
            }
            for (feature in concept.getOwnRoles()) {
                when (feature) {
                    is ProcessedProperty -> {
                        addProperty(
                            PropertySpec.builder(feature.generatedName, feature.asKotlinType())
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                String::class.asTypeName().copy(nullable = true),
                            )
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build(),
                        )
                    }

                    is ProcessedChildLink -> {
                        // TODO resolve link.type and ensure it exists
                        val accessorSubclass =
                            if (feature.multiple) ChildListAccessor::class else SingleChildAccessor::class
                        val type = accessorSubclass.asClassName()
                            .parameterizedBy(
                                feature.type.resolved.nodeWrapperInterfaceType(),
                            )
                        addProperty(
                            PropertySpec.builder(feature.generatedName, type)
                                .addDeprecationIfNecessary(feature)
                                .build(),
                        )
                    }

                    is ProcessedReferenceLink -> {
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName,
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = feature.optional),
                            )
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                feature.generatedName + "_orNull",
                                feature.type.resolved.nodeWrapperInterfaceType().copy(nullable = true),
                            )
                                .mutable(false)
                                .build(),
                        )
                        addProperty(
                            PropertySpec.builder(
                                "raw_" + feature.generatedName,
                                INode::class.asTypeName().copy(nullable = true),
                            )
                                .addDeprecationIfNecessary(feature)
                                .mutable(true)
                                .build(),
                        )
                    }
                }
            }
        }.build()
    }

    private fun ProcessedConcept.conceptWrapperInterfaceType() =
        conceptWrapperInterfaceClass().parameterizedBy(nodeWrapperInterfaceType())

    private fun ProcessedConcept.conceptWrapperInterfaceClass() =
        ClassName(language.name, nameConfig.typedConcept(name))

    internal fun ProcessedLanguage.generatedClassName() = ClassName(name, nameConfig.languageClass(name))
    private fun ProcessedConcept.nodeWrapperInterfaceName() = nameConfig.typedNode(name)
    private fun ProcessedConcept.nodeWrapperImplName() = nameConfig.typedNodeImpl(name)
    private fun ProcessedConcept.conceptObjectName() = nameConfig.untypedConcept(name)
    private fun ProcessedConcept.conceptTypeAliasName() = nameConfig.conceptTypeAlias(name)
    // private fun ProcessedConcept.conceptWrapperImplName() = nameConfig.conceptWrapperImplName(name)
    // private fun ProcessedConcept.conceptWrapperInterfaceName() = nameConfig.conceptWrapperInterfaceName(name)

    // private fun ProcessedConcept.getConceptFqName() = language.name + "." + name
    private fun ProcessedConcept.conceptObjectType() = ClassName(language.name, conceptObjectName())
    private fun ProcessedConcept.nodeWrapperImplType() = ClassName(language.name, nodeWrapperImplName())
    private fun ProcessedConcept.nodeWrapperInterfaceType() = ClassName(language.name, nodeWrapperInterfaceName())

    // private fun ProcessedRole.kotlinRef() = CodeBlock.of("%T.%N", concept.conceptObjectType(), generatedName)
    private fun ProcessedRole.returnKotlinRef() =
        CodeBlock.of("return %T.%N", concept.conceptObjectType(), generatedName)

    private fun ProcessedChildLink.generatedChildLinkType(): TypeName {
        val childConcept = type.resolved
        val linkClass = if (multiple) {
            GeneratedChildListLink::class
        } else {
            if (optional) GeneratedSingleChildLink::class else GeneratedMandatorySingleChildLink::class
        }
        return linkClass.asClassName().parameterizedBy(
            childConcept.nodeWrapperInterfaceType(),
            childConcept.conceptWrapperInterfaceType(),
        )
    }

    private fun ProcessedReferenceLink.generatedReferenceLinkType(): TypeName {
        val targetConcept = type.resolved
        return GeneratedReferenceLink::class.asClassName().parameterizedBy(
            targetConcept.nodeWrapperInterfaceType(),
            targetConcept.conceptWrapperInterfaceType(),
        )
    }
}

private fun List<TypeName>.toListLiteralCodeBlock(): CodeBlock {
    val list = this
    return CodeBlock.builder().apply {
        add("return listOf(\n")
        withIndent {
            for (element in list) {
                add("%T,\n", element)
            }
        }
        add(")")
    }.build()
}

internal fun generateDeprecationAnnotation(message: String): AnnotationSpec {
    val annotationBuilder = AnnotationSpec.builder(Deprecated::class)
    if (message.isNotEmpty()) { annotationBuilder.addMember("message = %S", message) }
    return annotationBuilder.build()
}

internal fun TypeSpec.Builder.addDeprecationIfNecessary(deprecatable: IProcessedDeprecatable): TypeSpec.Builder {
    return deprecatable.deprecationMessage?.let { addAnnotation(generateDeprecationAnnotation(it)) } ?: this
}

internal fun PropertySpec.Builder.addDeprecationIfNecessary(deprecatable: IProcessedDeprecatable): PropertySpec.Builder {
    return deprecatable.deprecationMessage?.let { addAnnotation(generateDeprecationAnnotation(it)) } ?: this
}

internal inline fun FunSpec.Builder.runBuild(crossinline body: FunSpec.Builder.() -> Unit): FunSpec {
    body()
    return build()
}

internal inline fun TypeSpec.Builder.runBuild(crossinline body: TypeSpec.Builder.() -> Unit): TypeSpec {
    body()
    return build()
}

internal inline fun FileSpec.Builder.runBuild(crossinline body: FileSpec.Builder.() -> Unit): FileSpec {
    body()
    return build()
}

internal inline fun PropertySpec.Builder.runBuild(crossinline body: PropertySpec.Builder.() -> Unit): PropertySpec {
    body()
    return build()
}

internal inline fun CodeBlock.Builder.runBuild(crossinline body: CodeBlock.Builder.() -> Unit): CodeBlock {
    body()
    return build()
}
