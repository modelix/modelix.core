package org.modelix.model.mpsadapters.mps;

/*Generated by MPS */

import org.modelix.model.area.IArea;
import org.modelix.model.area.IAreaReference;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.IConcept;
import org.modelix.model.api.IConceptReference;
import org.modelix.model.api.ConceptReference;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.language.ConceptRegistry;
import jetbrains.mps.smodel.runtime.illegal.IllegalConceptDescriptor;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.Objects;
import kotlin.jvm.functions.Function0;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.ModelAccess;
import jetbrains.mps.smodel.GlobalModelAccess;
import org.modelix.model.api.INode;
import org.modelix.model.area.IAreaListener;
import org.modelix.model.api.INodeReference;
import org.jetbrains.mps.openapi.model.SNode;
import org.modelix.model.api.IBranch;
import java.util.List;
import java.util.Collections;

public class MPSArea implements IArea, IAreaReference {

  private SRepository repository;

  public MPSArea() {
    this(MPSModuleRepository.getInstance());
  }

  public MPSArea(SRepository repository) {
    this.repository = repository;
  }

  @Override
  public long getLockOrderingPriority() {
    return 100L << 32;
  }

  @NotNull
  @Override
  public IAreaReference getReference() {
    return this;
  }

  @Nullable
  @Override
  public IConcept resolveConcept(@NotNull IConceptReference reference) {
    if (!(reference instanceof ConceptReference)) {
      return null;
    }
    String uid = ((ConceptReference) reference).getUid();
    if (uid.startsWith("mps:")) {
      uid = uid.substring(4);
    }
    SConceptId conceptId;
    try {
      conceptId = SConceptId.deserialize(uid);
    } catch (Exception ex) {
      return null;
    }
    if (conceptId == null) {
      return null;
    }
    ConceptDescriptor conceptDescriptor = ConceptRegistry.getInstance().getConceptDescriptor(conceptId);
    if (conceptDescriptor instanceof IllegalConceptDescriptor) {
      return null;
    }
    return SConceptAdapter.wrap(MetaAdapterFactory.getAbstractConcept(conceptDescriptor));
  }

  @Nullable
  @Override
  public IArea resolveArea(@NotNull IAreaReference reference) {
    return (Objects.equals(reference, this) ? this : null);
  }

  public SRepository getRepository() {
    return repository;
  }

  @Override
  public boolean canRead() {
    return getRepository().getModelAccess().canRead();
  }

  @Override
  public boolean canWrite() {
    return getRepository().getModelAccess().canWrite();
  }

  @Override
  public <T> T executeRead(@NotNull final Function0<? extends T> f) {
    final Wrappers._T<T> result = new Wrappers._T<T>();
    getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        result.value = f.invoke();
      }
    });
    return result.value;
  }

  @Override
  public <T> T executeWrite(@NotNull final Function0<? extends T> f) {
    final Wrappers._T<T> result = new Wrappers._T<T>();
    ModelAccess modelAccess = getRepository().getModelAccess();
    if (modelAccess instanceof GlobalModelAccess) {
      modelAccess.runWriteAction(new Runnable() {
        public void run() {
          result.value = f.invoke();
        }
      });
    } else {
      modelAccess.executeCommand(new Runnable() {
        public void run() {
          result.value = f.invoke();
        }
      });
    }
    return result.value;
  }

  @NotNull
  @Override
  public INode getRoot() {
    return new SRepositoryAsNode(getRepository());
  }

  @Override
  public void addListener(@NotNull IAreaListener listener) {
    throw new UnsupportedOperationException("Not implemented yet");
  }

  @Override
  public void removeListener(@NotNull IAreaListener listener) {
    throw new UnsupportedOperationException("Not implemented yet");
  }

  @Nullable
  @Override
  public INode resolveNode(@NotNull INodeReference reference) {
    return resolveOriginalNode(reference);
  }

  @Nullable
  @Override
  public INode resolveOriginalNode(@NotNull INodeReference reference) {
    if (reference instanceof SNodeReferenceAdapter) {
      SNode mpsNode = ((SNodeReferenceAdapter) reference).getReference().resolve(getRepository());
      return SNodeToNodeAdapter.wrap(mpsNode);
    }
    return null;
  }

  @Nullable
  @Override
  public IBranch resolveBranch(@NotNull String id) {
    return null;
  }

  @NotNull
  @Override
  public List<IArea> collectAreas() {
    return Collections.<IArea>singletonList(this);
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    MPSArea that = (MPSArea) o;
    if ((repository != null ? !(repository.equals(that.repository)) : that.repository != null)) {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    int result = 0;
    result = 31 * result + ((repository != null ? ((Object) repository).hashCode() : 0));
    return result;
  }
}
