package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import java.util.HashSet;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.modelix.model.api.IBranch;
import org.modelix.model.api.ITreeChangeVisitor;
import org.modelix.model.api.ITree;
import org.modelix.model.api.IWriteTransaction;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Level;

public abstract class Binding {
  private static final Logger LOG = LogManager.getLogger(Binding.class);
  private Binding owner;
  private Set<Binding> ownedBindings = SetSequence.fromSet(new LinkedHashSet<Binding>());
  private boolean isActive = false;
  private List<IListener> listeners = ListSequence.fromList(new ArrayList<IListener>());
  @Nullable
  protected SyncDirection initialSyncDirection;
  @Nullable
  protected SyncTask lastTask;
  @Nullable
  public SyncTask runningTask;

  public Binding(@Nullable SyncDirection initialSyncDirection) {
    this.initialSyncDirection = initialSyncDirection;
  }

  protected void assertSyncThread() {
    getRootBinding().getSyncQueue().assertSyncThread();
  }

  public int getDepth() {
    return (owner == null ? 0 : owner.getDepth() + 1);
  }

  public SyncTask getPendingTask() {
    return this.lastTask;
  }

  public SyncTask createTask(@NotNull SyncDirection direction, boolean initial) {
    switch (direction) {
      case TO_CLOUD:
        return new SyncTask(this, direction, initial, SetSequence.fromSetAndArray(new HashSet<ELockType>(), ELockType.MPS_READ, ELockType.CLOUD_WRITE), new Runnable() {
          public void run() {
            syncToCloud();
          }
        });
      case TO_MPS:
        // Even if the ITree is passed to the sync method we still need a read transaction on the cloud model 
        // ITree.getReferenceTarget(...).resolveNode(...) requires a read transaction
        return new SyncTask(this, direction, initial, SetSequence.fromSetAndArray(new HashSet<ELockType>(), ELockType.MPS_COMMAND, ELockType.CLOUD_READ), new Runnable() {
          public void run() {
            syncToMPS(getBranch().getTransaction().getTree());
          }
        });
      default:
        throw new RuntimeException("Unknown direction: " + direction);
    }
  }

  public SyncTask createTask(@NotNull SyncDirection direction, boolean initial, Runnable callback) {
    SyncTask task = createTask(direction, initial);
    task.whenDone(callback);
    return task;
  }

  public synchronized Set<ELockType> getRequiredSyncLocks(SyncDirection direction) {
    if (direction == null) {
      return Collections.<ELockType>emptySet();
    } else {
      switch (direction) {
        case TO_CLOUD:
          return SetSequence.fromSetAndArray(new HashSet<ELockType>(), ELockType.MPS_READ, ELockType.CLOUD_WRITE);
        case TO_MPS:
          // Even if the ITree is passed to the sync method we still need a read transaction on the cloud model 
          // ITree.getReferenceTarget(...).resolveNode(...) requires a read transaction
          return SetSequence.fromSetAndArray(new HashSet<ELockType>(), ELockType.MPS_COMMAND, ELockType.CLOUD_READ);
        default:
          throw new RuntimeException("Unknown direction: " + direction);
      }
    }
  }

  public void enqueueSync(@NotNull SyncDirection direction, boolean initial, @Nullable Runnable callback) {
    if (isSynchronizing()) {
      return;
    }
    forceEnqueueSyncTo(direction, initial, callback);
  }

  public void forceEnqueueSyncTo(@NotNull SyncDirection direction, boolean initial, @Nullable Runnable callback) {
    SyncTask task = createTask(direction, initial, callback);
    boolean isEnqueued = getRootBinding().getSyncQueue().enqueue(task);
    if (isEnqueued) {
      lastTask = task;
    }
  }

  public boolean isDone() {
    return (lastTask == null || lastTask.isDone()) && Sequence.fromIterable(getOwnedBindings()).all(new IWhereFilter<Binding>() {
      public boolean accept(Binding it) {
        return it.isDone();
      }
    });
  }

  public IBranch getBranch() {
    if (owner != null) {
      return owner.getBranch();
    }
    return null;
  }

  /**
   * It's more efficient to diff the tree only once and notify all bindings together about changes instead of calling
   * ITree.visitChanges in each binding.
   * First the visitor is notified about changes and then syncToMPS is called. The binding has to remember which model
   * elements are dirty.
   */
  @Nullable
  protected abstract ITreeChangeVisitor getTreeChangeVisitor(ITree oldTree, ITree newTree);

  public boolean isActive() {
    return isActive;
  }

  protected void checkActive() throws IllegalStateException {
    if (!(isActive)) {
      throw new IllegalStateException("Activate the binding first: " + this);
    }
  }

  public boolean isSynchronizing() {
    return check_cvbvhu_a0a63(runningTask);
  }

  public final void syncToMPS(@NotNull ITree tree) {
    assertSyncThread();
    checkActive();
    doSyncToMPS(tree);
  }

  protected abstract void doSyncToMPS(@NotNull ITree tree);

  public final void syncToCloud() {
    assertSyncThread();
    checkActive();
    syncToCloud(getBranch().getWriteTransaction());
  }

  public final void syncToCloud(IWriteTransaction t) {
    assertSyncThread();
    checkActive();
    doSyncToCloud(t);
  }

  public abstract void doSyncToCloud(IWriteTransaction t);

  public ICloudRepository getCloudRepository() {
    if (owner == null) {
      return null;
    } else {
      return owner.getCloudRepository();
    }
  }

  public void setOwner(@Nullable final Binding newOwner) {
    if (this.owner == newOwner) {
      return;
    }
    if (isActive) {
      deactivate(null);
    }
    if (newOwner == this) {
      throw new IllegalArgumentException("Binding can't own itself");
    }
    if (newOwner != null && Sequence.fromIterable(newOwner.getOwners()).contains(this)) {
      throw new IllegalArgumentException("Binding would be an indirect owner of itself");
    }
    if (this.owner != null) {
      SetSequence.fromSet(this.owner.ownedBindings).removeElement(this);
      this.owner.notifyListeners(new _FunctionTypes._void_P1_E0<IListener>() {
        public void invoke(IListener l) {
          l.bindingRemoved(Binding.this);
        }
      });
    }
    this.owner = newOwner;
    if (newOwner != null) {
      SetSequence.fromSet(newOwner.ownedBindings).addElement(this);
      if (newOwner.isActive()) {
        this.activate(null);
      }
      newOwner.notifyListeners(new _FunctionTypes._void_P1_E0<IListener>() {
        public void invoke(IListener l) {
          l.bindingAdded(Binding.this);
        }
      });
    }
    this.notifyListeners(new _FunctionTypes._void_P1_E0<IListener>() {
      public void invoke(IListener l) {
        l.ownerChanged(newOwner);
      }
    });
  }

  public Binding getOwner() {
    return owner;
  }

  public Iterable<Binding> getOwnedBindings() {
    return ownedBindings;
  }

  public Iterable<Binding> getOwners() {
    return (owner == null ? Sequence.fromIterable(Collections.<Binding>emptyList()) : Sequence.fromIterable(Sequence.<Binding>singleton(owner)).concat(Sequence.fromIterable(owner.getOwners())));
  }

  public Binding getRootOwnerOrSelf() {
    return (owner == null ? this : owner.getRootOwnerOrSelf());
  }

  public RootBinding getRootBinding() {
    RootBinding root = as_cvbvhu_a0a0a16(getRootOwnerOrSelf(), RootBinding.class);
    if (root == null) {
      throw new IllegalStateException("Not attached: " + this);
    }
    return root;
  }

  public Iterable<Binding> getAllBindings() {
    return Sequence.fromIterable(Sequence.<Binding>singleton(this)).concat(SetSequence.fromSet(ownedBindings).translate(new ITranslator2<Binding, Binding>() {
      public Iterable<Binding> translate(Binding it) {
        return it.getAllBindings();
      }
    }));
  }

  public final synchronized void activate(@Nullable Runnable callback) {
    if (!(getRootOwnerOrSelf() instanceof RootBinding)) {
      throw new IllegalStateException("Set an owner first: " + this);
    }
    if (isActive) {
      return;
    }
    if (!(this instanceof RootBinding) && !(owner.isActive())) {
      throw new IllegalStateException("Activate " + owner + " first, before activating " + this);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Activate: " + this);
    }
    isActive = true;
    doActivate();
    if (getRootBinding().getSyncQueue().getTask(this) == null) {
      enqueueSync((initialSyncDirection != null ? initialSyncDirection : SyncDirection.TO_MPS), true, callback);
    }
    notifyListeners(new _FunctionTypes._void_P1_E0<IListener>() {
      public void invoke(IListener l) {
        l.bindingActivated();
      }
    });
  }

  public final synchronized void deactivate(@Nullable Runnable callback) {
    if (!(isActive)) {
      return;
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Deactivate: " + this);
    }
    isActive = false;
    for (Binding child : SetSequence.fromSet(ownedBindings)) {
      child.deactivate(null);
    }
    doDeactivate();
    notifyListeners(new _FunctionTypes._void_P1_E0<IListener>() {
      public void invoke(IListener l) {
        l.bindingDeactivated();
      }
    });
    check_cvbvhu_a6a66(callback);
  }

  protected abstract void doActivate();
  protected abstract void doDeactivate();

  public void addListener(IListener l) {
    ListSequence.fromList(listeners).addElement(l);
  }

  public void removeListener(IListener l) {
    ListSequence.fromList(listeners).removeElement(l);
  }

  protected void notifyListeners(final _FunctionTypes._void_P1_E0<? super IListener> notifier) {
    ListSequence.fromList(listeners).visitAll(new IVisitor<IListener>() {
      public void visit(IListener it) {
        try {
          notifier.invoke(it);
        } catch (Exception ex) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("", ex);
          }
        }
      }
    });
  }

  public interface IListener {
    void bindingAdded(Binding binding);
    void bindingRemoved(Binding binding);
    void ownerChanged(Binding newOwner);
    void bindingActivated();
    void bindingDeactivated();
  }
  private static boolean check_cvbvhu_a0a63(SyncTask checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.isRunning();
    }
    return false;
  }
  private static void check_cvbvhu_a6a66(Runnable checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.run();
    }

  }
  private static <T> T as_cvbvhu_a0a0a16(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
