package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Set;
import org.modelix.model.operations.RoleInNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import gnu.trove.set.hash.TLongHashSet;
import org.jetbrains.mps.openapi.model.SNodeChangeListener;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.event.SPropertyChangeEvent;
import org.modelix.model.api.IBranch;
import org.modelix.model.area.PArea;
import kotlin.jvm.functions.Function0;
import kotlin.Unit;
import org.modelix.model.api.IWriteTransaction;
import org.apache.log4j.Level;
import org.jetbrains.mps.openapi.event.SReferenceChangeEvent;
import org.jetbrains.mps.openapi.event.SNodeAddEvent;
import org.jetbrains.mps.openapi.event.SNodeRemoveEvent;
import jetbrains.mps.smodel.event.SModelListener;
import jetbrains.mps.smodel.event.SModelLanguageEvent;
import jetbrains.mps.smodel.event.SModelDevKitEvent;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelRenamedEvent;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.smodel.event.SModelImportEvent;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.smodel.SModelInternal;
import org.modelix.model.api.ITree;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import gnu.trove.procedure.TLongProcedure;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.ITreeChangeVisitor;
import org.modelix.model.api.ITreeChangeVisitorEx;
import java.util.Objects;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class ModelBinding extends Binding {
  private static final Logger LOG = LogManager.getLogger(ModelBinding.class);

  private SModel model;
  protected final long modelNodeId;
  private Set<RoleInNode> childrenSyncToMPSRequired = SetSequence.fromSet(new HashSet<RoleInNode>());
  private Set<RoleInNode> referenceSyncToMPSRequired = SetSequence.fromSet(new HashSet<RoleInNode>());
  private Set<RoleInNode> propertySyncToMPSRequired = SetSequence.fromSet(new HashSet<RoleInNode>());
  private TLongHashSet fullNodeSyncToMPSRequired = new TLongHashSet();
  private boolean modelPropertiesSyncToMPSRequired = true;
  private ModelSynchronizer synchronizer;
  private SNodeChangeListener nodeChangeListener = new SNodeChangeListener() {
    @Override
    public void propertyChanged(@NotNull final SPropertyChangeEvent e) {
      try {
        if (isSynchronizing()) {
          return;
        }
        final IBranch branch = getBranch();
        new PArea(branch).executeWrite(new Function0<Unit>() {
          public Unit invoke() {
            synchronizer.runAndFlushReferences(new Runnable() {
              public void run() {
                IWriteTransaction t = branch.getWriteTransaction();
                long id = synchronizer.getOrSyncToCloud(e.getNode(), t);
                if (id != 0L && t.containsNode(id)) {
                  t.setProperty(id, e.getProperty().getName(), e.getNewValue());
                }
              }
            });
            return Unit.INSTANCE;
          }
        });
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }

    @Override
    public void referenceChanged(@NotNull final SReferenceChangeEvent e) {
      try {
        if (isSynchronizing()) {
          return;
        }
        synchronizer.runAndFlushReferences(new Runnable() {
          public void run() {
            synchronizer.handleReferenceChanged(e);
          }
        });
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }

    @Override
    public void nodeAdded(@NotNull final SNodeAddEvent e) {
      try {
        if (isSynchronizing()) {
          return;
        }
        synchronizer.runAndFlushReferences(new Runnable() {
          public void run() {
            synchronizer.handleMPSNodeAdded(e);
          }
        });
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }

    @Override
    public void nodeRemoved(@NotNull final SNodeRemoveEvent e) {
      try {
        if (isSynchronizing()) {
          return;
        }
        synchronizer.runAndFlushReferences(new Runnable() {
          public void run() {
            synchronizer.handleMPSNodeRemoved(e);
          }
        });
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }
  };
  private SModelListener modelListener = new SModelListener() {

    @Override
    public void languageAdded(SModelLanguageEvent event) {
      try {
        if (isSynchronizing()) {
          return;
        }
        synchronizer.runAndFlushReferences(new Runnable() {
          public void run() {
            synchronizer.syncUsedLanguagesAndDevKitsFromMPS();
          }
        });
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }
    @Override
    public void languageRemoved(SModelLanguageEvent event) {
      try {
        if (isSynchronizing()) {
          return;
        }
        synchronizer.runAndFlushReferences(new Runnable() {
          public void run() {
            synchronizer.syncUsedLanguagesAndDevKitsFromMPS();
          }
        });
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }
    @Override
    public void devkitAdded(SModelDevKitEvent event) {
      try {
        if (isSynchronizing()) {
          return;
        }
        synchronizer.runAndFlushReferences(new Runnable() {
          public void run() {
            synchronizer.syncUsedLanguagesAndDevKitsFromMPS();
          }
        });
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }
    @Override
    public void devkitRemoved(SModelDevKitEvent event) {
      try {
        if (isSynchronizing()) {
          return;
        }
        synchronizer.runAndFlushReferences(new Runnable() {
          public void run() {
            synchronizer.syncUsedLanguagesAndDevKitsFromMPS();
          }
        });
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }

    @Override
    public void beforeChildRemoved(SModelChildEvent event) {
    }
    @Override
    public void beforeModelDisposed(SModel model) {
    }
    @Override
    public void beforeModelRenamed(SModelRenamedEvent event) {
    }
    @Override
    public void beforeRootRemoved(SModelRootEvent event) {
    }
    @Override
    public void childAdded(SModelChildEvent event) {
    }
    @Override
    public void childRemoved(SModelChildEvent event) {
    }
    @NotNull
    @Override
    public SModelListener.SModelListenerPriority getPriority() {
      return SModelListener.SModelListenerPriority.CLIENT;
    }
    @Override
    public void importAdded(SModelImportEvent event) {
      try {
        if (isSynchronizing()) {
          return;
        }
        synchronizer.runAndFlushReferences(new Runnable() {
          public void run() {
            synchronizer.syncModelImportsFromMPS();
          }
        });
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }
    @Override
    public void importRemoved(SModelImportEvent event) {
      try {
        if (isSynchronizing()) {
          return;
        }
        synchronizer.runAndFlushReferences(new Runnable() {
          public void run() {
            synchronizer.syncModelImportsFromMPS();
          }
        });
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }
    @Override
    public void modelLoadingStateChanged(SModel model, ModelLoadingState state) {
    }
    @Override
    public void modelRenamed(SModelRenamedEvent event) {
    }
    @Override
    public void modelSaved(SModel model) {
    }
    @Override
    public void propertyChanged(SModelPropertyEvent event) {
    }
    @Override
    public void referenceAdded(SModelReferenceEvent event) {
    }
    @Override
    public void referenceRemoved(SModelReferenceEvent event) {
    }
    @Deprecated
    @Override
    public void rootAdded(SModelRootEvent event) {
    }
    @Deprecated
    @Override
    public void rootRemoved(SModelRootEvent event) {
    }
  };

  public ModelBinding(long modelNodeId, SModel model, SyncDirection initialSyncDirection) {
    super(initialSyncDirection);
    this.model = model;
    this.modelNodeId = modelNodeId;
  }

  public SModel getModel() {
    return this.model;
  }

  public long getModelNodeId() {
    return this.modelNodeId;
  }

  @Override
  public String toString() {
    return "Model: " + Long.toHexString(modelNodeId) + " -> " + model.getName().getValue();
  }

  @Override
  protected void doActivate() {
    synchronizer = new ModelSynchronizer(modelNodeId, model, getCloudRepository());
    model.addChangeListener(nodeChangeListener);
    ((SModelInternal) model).addModelListener(modelListener);
  }
  @Override
  protected void doDeactivate() {
    model.removeChangeListener(nodeChangeListener);
    ((SModelInternal) model).removeModelListener(modelListener);
    synchronizer = null;
  }
  @Override
  public void doSyncToCloud(IWriteTransaction t) {
    synchronizer.fullSyncFromMPS();
  }
  @Override
  protected void doSyncToMPS(@NotNull final ITree tree) {
    if (runningTask.isInitialSync) {
      Iterable<SNode> mpsRootNodes = model.getRootNodes();
      Iterable<Long> cloudRootNodes = tree.getChildren(modelNodeId, LINKS.rootNodes$jxXY.getName());
      if (Sequence.fromIterable(mpsRootNodes).isNotEmpty() && Sequence.fromIterable(cloudRootNodes).isEmpty()) {
        // TODO remove this workaround
        forceEnqueueSyncTo(SyncDirection.TO_CLOUD, true, null);
      } else {
        synchronizer.syncModelToMPS(tree, false);
      }
    } else {
      synchronizer.runAndFlushReferences(new Runnable() {
        public void run() {
          for (RoleInNode roleInNode : SetSequence.fromSet(childrenSyncToMPSRequired)) {
            try {
              if (tree.containsNode(roleInNode.getNodeId())) {
                synchronizer.syncChildrenToMPS(roleInNode.getNodeId(), roleInNode.getRole(), tree, false);
              }
            } catch (Exception ex) {
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex);
              }
            }
          }
          SetSequence.fromSet(childrenSyncToMPSRequired).clear();

          for (RoleInNode roleInNode : SetSequence.fromSet(referenceSyncToMPSRequired)) {
            try {
              if (tree.containsNode(roleInNode.getNodeId())) {
                synchronizer.syncReferenceToMPS(roleInNode.getNodeId(), roleInNode.getRole(), tree);
              }
            } catch (Exception ex) {
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex);
              }
            }
          }
          SetSequence.fromSet(referenceSyncToMPSRequired).clear();

          for (RoleInNode roleInNode : SetSequence.fromSet(propertySyncToMPSRequired)) {
            try {
              if (tree.containsNode(roleInNode.getNodeId())) {
                synchronizer.syncPropertyToMPS(roleInNode.getNodeId(), roleInNode.getRole(), tree);
              }
            } catch (Exception ex) {
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex);
              }
            }
          }
          SetSequence.fromSet(propertySyncToMPSRequired).clear();

          fullNodeSyncToMPSRequired.forEach(new TLongProcedure() {
            public boolean execute(long nodeId) {
              try {
                if (tree.containsNode(nodeId)) {
                  synchronizer.syncNodeToMPS(nodeId, tree, true);
                }
              } catch (Exception ex) {
                if (LOG.isEnabledFor(Level.ERROR)) {
                  LOG.error("", ex);
                }
              }
              return true;
            }
          });
          fullNodeSyncToMPSRequired.clear();

          if (modelPropertiesSyncToMPSRequired) {
            try {
              synchronizer.syncModelPropertiesToMPS(tree);
            } catch (Exception ex) {
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("", ex);
              }
            }
          }
        }
      });
      modelPropertiesSyncToMPSRequired = false;
    }
  }

  @Nullable
  @Override
  protected ITreeChangeVisitor getTreeChangeVisitor(final ITree oldTree, final ITree newTree) {
    return new ITreeChangeVisitorEx() {
      public boolean isInsideModel(long nodeId) {
        assertSyncThread();
        long parent = newTree.getParent(nodeId);
        if (parent == 0) {
          return false;
        }
        if (parent == modelNodeId) {
          return Objects.equals(newTree.getRole(nodeId), LINKS.rootNodes$jxXY.getName());
        }
        return isInsideModel(parent);
      }
      public boolean isInsideModelOrModel(long nodeId) {
        assertSyncThread();
        if (nodeId == modelNodeId) {
          return true;
        }
        return isInsideModel(nodeId);
      }
      public boolean isModelProperties(long nodeId) {
        assertSyncThread();
        long parent = newTree.getParent(nodeId);
        if (parent == 0) {
          return false;
        }
        if (parent == modelNodeId) {
          return !(Objects.equals(newTree.getRole(nodeId), LINKS.rootNodes$jxXY.getName()));
        }
        return isModelProperties(parent);
      }

      @Override
      public void containmentChanged(long nodeId) {
      }

      @Override
      public void childrenChanged(final long nodeId, final String role) {
        assertSyncThread();
        if (modelNodeId == nodeId) {
          if (Objects.equals(role, LINKS.rootNodes$jxXY.getName())) {
            SetSequence.fromSet(childrenSyncToMPSRequired).addElement(new RoleInNode(nodeId, role));
          } else {
            modelPropertiesSyncToMPSRequired = true;
          }
        } else if (isModelProperties(nodeId)) {
          modelPropertiesSyncToMPSRequired = true;
        } else if (isInsideModel(nodeId)) {
          SetSequence.fromSet(childrenSyncToMPSRequired).addElement(new RoleInNode(nodeId, role));
        }
        enqueueSync(SyncDirection.TO_MPS, false, null);
      }

      @Override
      public void referenceChanged(long nodeId, String role) {
        assertSyncThread();
        if (isModelProperties(nodeId)) {
          modelPropertiesSyncToMPSRequired = true;
          enqueueSync(SyncDirection.TO_MPS, false, null);
          return;
        }
        if (!(isInsideModel(nodeId))) {
          return;
        }
        SetSequence.fromSet(referenceSyncToMPSRequired).addElement(new RoleInNode(nodeId, role));
        enqueueSync(SyncDirection.TO_MPS, false, null);
      }

      @Override
      public void propertyChanged(final long nodeId, String role) {
        assertSyncThread();
        if (isModelProperties(nodeId)) {
          modelPropertiesSyncToMPSRequired = true;
          enqueueSync(SyncDirection.TO_MPS, false, null);
          return;
        }
        if (!(isInsideModel(nodeId))) {
          return;
        }
        SetSequence.fromSet(propertySyncToMPSRequired).addElement(new RoleInNode(nodeId, role));
        enqueueSync(SyncDirection.TO_MPS, false, null);
      }

      @Override
      public void nodeRemoved(long nodeId) {
      }

      @Override
      public void nodeAdded(long nodeId) {
        assertSyncThread();
        if (!(isInsideModel(nodeId))) {
          return;
        }
        fullNodeSyncToMPSRequired.add(nodeId);
        enqueueSync(SyncDirection.TO_MPS, false, null);
      }
    };
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink rootNodes$jxXY = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, 0x69652614fd1c514L, "rootNodes");
  }
}
