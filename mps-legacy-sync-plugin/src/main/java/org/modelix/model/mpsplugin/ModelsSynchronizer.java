package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.modelix.model.api.ITree;
import org.jetbrains.mps.openapi.model.SModelId;
import jetbrains.mps.model.ModelDeleteHelper;
import java.util.Map;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Objects;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.modelix.model.api.IWriteTransaction;
import org.modelix.model.mpsadapters.mps.SConceptAdapter;
import jetbrains.mps.project.Project;
import jetbrains.mps.project.ProjectManager;
import jetbrains.mps.lang.migration.runtime.base.VersionFixer;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SConcept;

public class ModelsSynchronizer extends Synchronizer<SModel> {

  private SModule module;

  public ModelsSynchronizer(long cloudParentId, SModule module) {
    super(cloudParentId, LINKS.models$h3QT.getName());
    this.module = module;
  }

  public SModule getModule() {
    return module;
  }

  @Override
  protected Iterable<SModel> getMPSChildren() {
    return ListSequence.fromList(SModuleUtils.getModelsWithoutDescriptor(module)).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel it) {
        return !(it.isReadOnly());
      }
    });
  }

  @Override
  protected SModel createMPSChild(ITree tree, long cloudChildId) {
    SModelId id = getModelId(tree, cloudChildId);
    if (id == null) {
      id = jetbrains.mps.smodel.SModelId.foreign("cloud-" + cloudChildId);
    }
    String name = tree.getProperty(cloudChildId, PROPS.name$MnvL.getName());
    return createModel(name, id, cloudChildId);
  }

  protected SModel createModel(String name, SModelId id, long modelNodeId) {
    return SModuleUtils.createModel(module, name, id);
  }

  @Override
  public void removeMPSChild(SModel mpsChild) {
    new ModelDeleteHelper(mpsChild).delete();
  }

  @Override
  public Map<Long, SModel> associate(ITree tree, List<Long> cloudChildren, List<SModel> mpsChildren, SyncDirection direction) {
    Map<Long, SModel> result = MapSequence.fromMap(new HashMap<Long, SModel>());
    List<SModel> availableModels = ListSequence.fromListWithValues(new ArrayList<SModel>(), mpsChildren);

    for (long cloudModelId : cloudChildren) {
      SModelId id = getModelId(tree, cloudModelId);
      String name = tree.getProperty(cloudModelId, PROPS.name$MnvL.getName());

      // There can be models with duplicate names. That's why we can't just search in a map.
      Iterator<SModel> itr = ListSequence.fromList(availableModels).iterator();
      while (itr.hasNext()) {
        SModel it = itr.next();
        if (id != null && Objects.equals(it.getModelId(), id) || Objects.equals(it.getName().getValue(), name)) {
          MapSequence.fromMap(result).put(cloudModelId, it);
          itr.remove();
          break;
        }
      }
    }

    return result;
  }

  protected SModelId getModelId(ITree tree, long cloudModelId) {
    String serializedId = tree.getProperty(cloudModelId, PROPS.id$lDUo.getName());
    if ((serializedId == null || serializedId.length() == 0)) {
      return null;
    }
    return PersistenceFacade.getInstance().createModelId(serializedId);
  }

  @Override
  public long createCloudChild(IWriteTransaction t, SModel mpsChild) {
    long modelNodeId = t.addNewChild(getCloudParentId(), LINKS.models$h3QT.getName(), -1, SConceptAdapter.wrap(CONCEPTS.Model$2P));
    t.setProperty(modelNodeId, PROPS.id$lDUo.getName(), mpsChild.getModelId().toString());
    t.setProperty(modelNodeId, PROPS.name$MnvL.getName(), mpsChild.getName().getValue());
    return modelNodeId;
  }


  @Override
  public Map<Long, SModel> syncToMPS(ITree tree) {
    Map<Long, SModel> result = super.syncToMPS(tree);

    List<Project> projects = ProjectManager.getInstance().getOpenedProjects();
    if (ListSequence.fromList(projects).isNotEmpty()) {
      new VersionFixer(ListSequence.fromList(projects).first(), module, true).updateImportVersions();
    }

    return result;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink models$h3QT = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50fL, 0x69652614fd1c512L, "models");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty id$lDUo = MetaAdapterFactory.getProperty(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, 0x244b85440ee67212L, "id");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Model$2P = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, "org.modelix.model.repositoryconcepts.structure.Model");
  }
}
