package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.modelix.model.api.ITreeChangeVisitor;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.module.SModuleListenerBase;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SModel;
import org.apache.log4j.Level;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.modelix.model.api.ITree;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Map;
import org.modelix.model.api.IWriteTransaction;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public abstract class ModuleBinding extends Binding {
  private static final Logger LOG = LogManager.getLogger(ModuleBinding.class);
  protected final long moduleNodeId;
  private ITreeChangeVisitor treeChangeVisitor = new ITreeChangeVisitor() {
    @Override
    public void childrenChanged(long nodeId, @Nullable String role) {
      assertSyncThread();
      if (nodeId == ModuleBinding.this.moduleNodeId) {
        enqueueSync(SyncDirection.TO_MPS, false, null);
      }
    }
    @Override
    public void containmentChanged(long nodeId) {
    }
    @Override
    public void referenceChanged(long nodeId, String role) {
    }
    @Override
    public void propertyChanged(long nodeId, String role) {
    }
  };
  private SModuleListenerBase moduleListener = new SModuleListenerBase() {
    @Override
    public void modelAdded(SModule module, SModel model) {
      try {
        enqueueSync(SyncDirection.TO_CLOUD, false, null);
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }
    @Override
    public void modelRemoved(SModule module, SModelReference ref) {
      try {
        enqueueSync(SyncDirection.TO_CLOUD, false, null);
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }
    @Override
    public void modelRenamed(SModule module, SModel model, SModelReference oldRef) {
      try {
        enqueueSync(SyncDirection.TO_CLOUD, false, null);
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }
  };

  public ModuleBinding(long moduleNodeId, SyncDirection initialSyncDirection) {
    super(initialSyncDirection);
    this.moduleNodeId = moduleNodeId;
  }

  @Override
  public String toString() {
    return "Module: " + Long.toHexString(moduleNodeId) + " -> " + check_rpydrg_a0a0g(getModule(), this);
  }

  public abstract SModule getModule();

  @Nullable
  @Override
  protected ITreeChangeVisitor getTreeChangeVisitor(final ITree oldTree, final ITree newTree) {
    return treeChangeVisitor;
  }

  @Override
  protected void doActivate() {
    getModule().addModuleListener(moduleListener);
    if (getRootBinding().getSyncQueue().getTask(this) == null) {
      enqueueSync((initialSyncDirection == null ? SyncDirection.TO_MPS : initialSyncDirection), true, null);
    }
  }

  @Override
  protected void doDeactivate() {
    getModule().removeModuleListener(moduleListener);
  }

  @Override
  protected void doSyncToMPS(@NotNull ITree tree) {
    if (runningTask.isInitialSync && Sequence.fromIterable(getModelsSynchronizer().getMPSChildren()).isNotEmpty() && Sequence.fromIterable(getModelsSynchronizer().getCloudChildren(tree)).isEmpty()) {
      // TODO remove this workaround
      forceEnqueueSyncTo(SyncDirection.TO_CLOUD, true, null);
      return;
    }

    Map<Long, SModel> mappings = getModelsSynchronizer().syncToMPS(tree);
    updateBindings(mappings, SyncDirection.TO_MPS);
  }

  @Override
  public void doSyncToCloud(IWriteTransaction t) {
    Map<Long, SModel> mappings = getModelsSynchronizer().syncToCloud(t);
    updateBindings(mappings, SyncDirection.TO_CLOUD);
  }

  private void updateBindings(final Map<Long, SModel> mappings, final SyncDirection syncDirection) {
    final Map<Long, ModelBinding> bindings = MapSequence.fromMap(new HashMap<Long, ModelBinding>());
    Sequence.fromIterable(getOwnedBindings()).ofType(ModelBinding.class).visitAll(new IVisitor<ModelBinding>() {
      public void visit(ModelBinding it) {
        MapSequence.fromMap(bindings).put(it.getModelNodeId(), it);
      }
    });

    List<Long> toAdd = SetSequence.fromSet(MapSequence.fromMap(mappings).keySet()).subtract(SetSequence.fromSet(MapSequence.fromMap(bindings).keySet())).toListSequence();
    List<Long> toRemove = SetSequence.fromSet(MapSequence.fromMap(bindings).keySet()).subtract(SetSequence.fromSet(MapSequence.fromMap(mappings).keySet())).toListSequence();

    ListSequence.fromList(toRemove).visitAll(new IVisitor<Long>() {
      public void visit(Long it) {
        ModelBinding binding = MapSequence.fromMap(bindings).get(it);
        binding.deactivate(null);
        binding.setOwner(null);
      }
    });

    ListSequence.fromList(toAdd).visitAll(new IVisitor<Long>() {
      public void visit(Long it) {
        ModelBinding binding = new ModelBinding(it, MapSequence.fromMap(mappings).get(it), syncDirection);
        binding.setOwner(ModuleBinding.this);
        binding.activate(null);
      }
    });
  }

  protected Synchronizer<SModel> getModelsSynchronizer() {
    return new ModelsSynchronizer(moduleNodeId, getModule());
  }

  public long getModuleNodeId() {
    return this.moduleNodeId;
  }
  private static String check_rpydrg_a0a0g(SModule checkedDotOperand, ModuleBinding checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModuleName();
    }
    return null;
  }
}
