package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.modelix.model.client.ReplicatedRepository;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.apache.log4j.Level;
import com.intellij.openapi.command.undo.DocumentReference;
import org.jetbrains.mps.openapi.repository.CommandListener;
import org.modelix.model.lazy.CLVersion;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.command.CommandProcessor;
import com.intellij.openapi.command.undo.UndoManager;
import org.modelix.model.client.IModelClient;
import org.modelix.model.lazy.RepositoryId;
import org.jetbrains.annotations.NotNull;
import java.util.function.Supplier;
import kotlin.jvm.functions.Function0;
import jetbrains.mps.smodel.MPSModuleRepository;
import com.intellij.openapi.command.undo.UndoableAction;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.intellij.openapi.command.undo.UnexpectedUndoException;
import org.modelix.model.area.PArea;
import kotlin.Unit;
import org.modelix.model.operations.OTWriteTransactionKt;
import org.modelix.model.operations.UndoOp;
import org.modelix.model.lazy.KVEntryReference;
import org.modelix.model.persistent.CPVersion;

public class MpsReplicatedRepository extends ReplicatedRepository {
  private static final Logger LOG = LogManager.getLogger(MpsReplicatedRepository.class);

  private static final Set<MpsReplicatedRepository> INSTANCES = SetSequence.fromSet(new HashSet<MpsReplicatedRepository>());

  public static void disposeAll() {
    List<MpsReplicatedRepository> list;
    synchronized (INSTANCES) {
      list = ListSequence.fromListWithValues(new ArrayList<MpsReplicatedRepository>(), INSTANCES);
    }
    for (MpsReplicatedRepository instance : ListSequence.fromList(list)) {
      try {
        instance.dispose();
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }
  }

  private static Set<DocumentReference> affectedDocuments = SetSequence.fromSet(new HashSet<DocumentReference>());

  public static void documentChanged(DocumentReference doc) {
    SetSequence.fromSet(affectedDocuments).addElement(doc);
  }

  private CommandListener commandListener = new CommandListener() {
    @Override
    public void commandStarted() {
      SetSequence.fromSet(affectedDocuments).clear();
      startEdit();
    }

    @Override
    public void commandFinished() {
      CLVersion version = endEdit();
      if (version == null) {
        return;
      }
      Project project = CommandProcessor.getInstance().getCurrentCommandProject();
      if (project == null) {
        return;
      }
      UndoManager undoManager = UndoManager.getInstance(project);
      undoManager.undoableActionPerformed(new ModelixUndoableAction(version, affectedDocuments));
    }
  };

  public MpsReplicatedRepository(final IModelClient client, final RepositoryId repositoryId, @NotNull final String branchName, final Supplier<String> user) {
    super(client, repositoryId, branchName, new Function0<String>() {
      @Override
      public String invoke() {
        return user.get();
      }
    });
    MPSModuleRepository.getInstance().getModelAccess().addCommandListener(commandListener);
    synchronized (INSTANCES) {
      SetSequence.fromSet(INSTANCES).addElement(this);
    }
  }

  public void dispose() {
    synchronized (INSTANCES) {
      SetSequence.fromSet(INSTANCES).removeElement(this);
    }
    if (isDisposed()) {
      return;
    }
    MPSModuleRepository.getInstance().getModelAccess().removeCommandListener(commandListener);
    super.dispose();
  }

  public class ModelixUndoableAction implements UndoableAction {
    private CLVersion version;
    private DocumentReference[] documents;
    public ModelixUndoableAction(CLVersion version, Iterable<DocumentReference> docs) {
      this.version = version;
      this.documents = Sequence.fromIterable(docs).toGenericArray(DocumentReference.class);
    }
    @Override
    public void undo() throws UnexpectedUndoException {
      new PArea(getBranch()).executeWrite(new Function0<Unit>() {
        @Override
        public Unit invoke() {
          OTWriteTransactionKt.applyOperation(getBranch().getWriteTransaction(), new UndoOp(new KVEntryReference<CPVersion>(version.getData())));
          return Unit.INSTANCE;
        }
      });
    }
    @Override
    public void redo() throws UnexpectedUndoException {
      throw new UnexpectedUndoException("Not supported yet");
    }
    @Override
    public DocumentReference[] getAffectedDocuments() {
      return (documents.length == 0 ? null : documents);
    }
    @Override
    public boolean isGlobal() {
      return documents.length == 0;
    }
  }
}
