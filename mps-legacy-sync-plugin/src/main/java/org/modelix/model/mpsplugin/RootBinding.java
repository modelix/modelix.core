package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.modelix.model.api.IBranchListener;
import org.modelix.model.lazy.RepositoryId;
import org.modelix.model.api.IBranch;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.api.ITree;
import java.util.Objects;
import java.util.List;
import org.modelix.model.api.ITreeChangeVisitor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.modelix.model.api.IWriteTransaction;
import org.jetbrains.annotations.Nullable;

/**
 * Just a parent for all actual bindings
 */
public class RootBinding extends Binding implements IBranchListener {

  private final ICloudRepository cloudRepository;
  private final SyncQueue syncQueue = new SyncQueue(this);
  private boolean disposed = false;

  public RootBinding(ICloudRepository cloudRepository) {
    super(null);
    this.cloudRepository = cloudRepository;
    activate(null);
  }

  public RootBinding(ModelServerConnection connection, RepositoryId cloudRepositoryId) {
    this(new CloudRepository(connection, cloudRepositoryId));
  }

  public SyncQueue getSyncQueue() {
    return syncQueue;
  }

  @Override
  public String toString() {
    return "bindings";
  }

  @Override
  public IBranch getBranch() {
    IBranch branch = super.getBranch();
    return (branch != null ? branch : cloudRepository.getBranch());
  }

  @Override
  @NotNull
  public ICloudRepository getCloudRepository() {
    return cloudRepository;
  }

  @Override
  public void treeChanged(@NotNull final ITree oldTree, @NotNull final ITree newTree) {
    if (syncQueue.isSynchronizing()) {
      return;
    }
    enqueueSync(SyncDirection.TO_MPS, false, null);
  }

  @Override
  protected void doSyncToMPS(@NotNull final ITree newTree) {
    assertSyncThread();
    final ITree oldTree = syncQueue.getLastTreeAfterSync();
    if (oldTree != null && !(Objects.equals(newTree, oldTree))) {
      List<ITreeChangeVisitor> visitors = Sequence.fromIterable(getAllBindings()).select(new ISelector<Binding, ITreeChangeVisitor>() {
        public ITreeChangeVisitor select(Binding it) {
          return it.getTreeChangeVisitor(oldTree, newTree);
        }
      }).where(new NotNullWhereFilter()).toListSequence();
      if (ListSequence.fromList(visitors).isNotEmpty()) {
        newTree.visitChanges(oldTree, new TreeChangeMulticaster(visitors));
      }
    }
  }

  @Override
  public void doSyncToCloud(IWriteTransaction t) {
  }

  @Nullable
  @Override
  protected ITreeChangeVisitor getTreeChangeVisitor(final ITree oldTree, final ITree newTree) {
    return null;
  }

  @Override
  protected void doActivate() {
    if (disposed) {
      throw new IllegalStateException("Reactivation not supported");
    }
    cloudRepository.getActiveBranch().addListener(this);
  }

  @Override
  protected void doDeactivate() {
    disposed = true;
    cloudRepository.getActiveBranch().removeListener(this);
    syncQueue.dispose();
  }
}
