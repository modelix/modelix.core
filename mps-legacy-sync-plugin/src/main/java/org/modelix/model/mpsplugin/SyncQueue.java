package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.modelix.model.api.ITree;
import org.jetbrains.annotations.Nullable;
import java.util.Set;
import java.util.function.Function;
import jetbrains.mps.internal.collections.runtime.LinkedListSequence;
import java.util.LinkedList;
import java.util.function.Consumer;
import java.util.Collections;
import java.util.Comparator;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Objects;
import java.util.HashSet;
import org.apache.log4j.Level;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.modelix.model.api.IBranch;
import org.modelix.model.area.PArea;
import kotlin.jvm.functions.Function0;
import kotlin.Unit;
import org.modelix.model.api.IWriteTransaction;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

public class SyncQueue {
  private static final Logger LOG = LogManager.getLogger(SyncQueue.class);
  private RootBinding owner;
  private final Map<Binding, SyncTask> syncQueue = MapSequence.fromMap(new LinkedHashMap<Binding, SyncTask>(16, (float) 0.75, false));
  private volatile boolean isSynchronizing = false;
  private final Object syncLock = new Object();
  private final List<ELockType> activeLocks = ListSequence.fromList(new ArrayList<ELockType>());
  private final FlushExecutor flushExecutor = new FlushExecutor();
  private Thread syncThread = null;
  private ITree lastTreeAfterSync = null;

  public SyncQueue(RootBinding owner) {
    this.owner = owner;
  }

  @Nullable
  public SyncTask getTask(Binding binding) {
    return MapSequence.fromMap(syncQueue).get(binding);
  }

  public ITree getLastTreeAfterSync() {
    return this.lastTreeAfterSync;
  }

  public void assertSyncThread() {
    if (Thread.currentThread() != syncThread) {
      throw new RuntimeException("Call only allowed from sync thread (" + syncThread + "), but current thread is " + Thread.currentThread());
    }
  }

  public void dispose() {
  }

  public boolean enqueue(SyncTask task) {
    if (task.binding.getRootBinding() != owner) {
      throw new IllegalArgumentException(task.binding + " is not attached to " + this);
    }
    synchronized (syncQueue) {
      SyncTask existingTask = MapSequence.fromMap(syncQueue).get(task.binding);
      if (existingTask != null) {
        if (existingTask.direction == task.direction && existingTask.isInitialSync == task.isInitialSync) {
          return false;
        }
        throw new RuntimeException("Cannot add " + task + ". Queue has pending " + existingTask);
      }
      MapSequence.fromMap(syncQueue).put(task.binding, task);
    }
    flushExecutor.submitFlush();
    return true;
  }


  public void flush() {
    flushExecutor.flush();
  }

  public boolean isSynchronizing() {
    return isSynchronizing;
  }

  private void loadFromQueue(Map<Set<ELockType>, List<SyncTask>> locks2tasks) {
    List<SyncTask> queueElements;
    synchronized (syncQueue) {
      queueElements = ListSequence.fromListWithValues(new ArrayList<SyncTask>(), MapSequence.fromMap(syncQueue).values());
      MapSequence.fromMap(syncQueue).clear();
    }
    for (SyncTask task : ListSequence.fromList(queueElements)) {
      ListSequence.fromList(locks2tasks.computeIfAbsent(task.requiredLocks, new Function<Set<ELockType>, List<SyncTask>>() {
        public List<SyncTask> apply(Set<ELockType> k) {
          return LinkedListSequence.fromLinkedListNew(new LinkedList<SyncTask>());
        }
      })).addElement(task);
    }
    locks2tasks.values().forEach(new Consumer<List<SyncTask>>() {
      public void accept(List<SyncTask> it) {
        Collections.sort(it, new Comparator<SyncTask>() {
          @Override
          public int compare(SyncTask t1, SyncTask t2) {
            return t1.binding.getDepth() - t2.binding.getDepth();
          }
        });
      }
    });
  }

  private void doFlush() {
    final List<SyncTask> processedTasks = ListSequence.fromList(new ArrayList<SyncTask>());
    synchronized (syncLock) {
      assert !(isSynchronizing);
      try {
        isSynchronizing = true;
        syncThread = Thread.currentThread();
        final Map<Set<ELockType>, List<SyncTask>> locks2task = new LinkedHashMap<Set<ELockType>, List<SyncTask>>();
        loadFromQueue(locks2task);
        while (Sequence.fromIterable(MapSequence.fromMap(locks2task).values()).translate(new ITranslator2<List<SyncTask>, SyncTask>() {
          public Iterable<SyncTask> translate(List<SyncTask> it) {
            return it;
          }
        }).isNotEmpty()) {
          for (final IMapping<Set<ELockType>, List<SyncTask>> entry : MapSequence.fromMap(locks2task).where(new IWhereFilter<IMapping<Set<ELockType>, List<SyncTask>>>() {
            public boolean accept(IMapping<Set<ELockType>, List<SyncTask>> it) {
              return ListSequence.fromList(it.value()).isNotEmpty();
            }
          })) {
            runWithLocks(SetSequence.fromSet(entry.key()).sort(new ISelector<ELockType, Integer>() {
              public Integer select(ELockType it) {
                return it.ordinal();
              }
            }, true).toListSequence(), new _FunctionTypes._void_P0_E0() {
              public void invoke() {
                List<SyncTask> tasks = entry.value();
                while (ListSequence.fromList(tasks).isNotEmpty()) {
                  while (ListSequence.fromList(tasks).isNotEmpty()) {
                    SyncTask task = ListSequence.fromList(tasks).removeElementAt(0);
                    if (!(Objects.equals(SetSequence.fromSetWithValues(new HashSet<ELockType>(), activeLocks), task.requiredLocks))) {
                      throw new IllegalStateException(task + " requires locks " + task.requiredLocks + ", but active locks are " + activeLocks);
                    }
                    ListSequence.fromList(processedTasks).addElement(task);
                    try {
                      task.run();
                    } catch (Exception ex) {
                      if (LOG.isEnabledFor(Level.ERROR)) {
                        LOG.error("Failed: " + task, ex);
                      }
                    }
                  }
                  loadFromQueue(locks2task);
                }
              }
            });
          }
        }
      } finally {
        isSynchronizing = false;
        syncThread = null;
      }
    }
    for (SyncTask task : ListSequence.fromList(processedTasks)) {
      try {
        task.invokeCallbacks();
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Exception in binding callback", ex);
        }
      }
    }
  }

  private void runWithLocks(final Iterable<ELockType> locks, final _FunctionTypes._void_P0_E0 body) {
    if (Sequence.fromIterable(locks).isEmpty()) {
      body.invoke();
    } else {
      runWithLock(Sequence.fromIterable(locks).first(), new Runnable() {
        public void run() {
          runWithLocks(Sequence.fromIterable(locks).skip(1), body);
        }
      });
    }
  }

  private void runWithLock(ELockType type, final Runnable body) {
    assertSyncThread();
    if (ListSequence.fromList(activeLocks).contains(type)) {
      throw new IllegalStateException("Lock " + type + " is already active");
    }
    try {
      ListSequence.fromList(activeLocks).addElement(type);
      switch (type) {
        case MPS_COMMAND:
          CommandHelper.runInUndoTransparentCommand(new Runnable() {
            public void run() {
              Thread previousSyncThread = syncThread;
              try {
                syncThread = Thread.currentThread();
                body.run();
              } finally {
                syncThread = previousSyncThread;
              }
            }
          });
          break;
        case MPS_READ:
          MPSModuleRepository.getInstance().getModelAccess().runReadAction(new Runnable() {
            public void run() {
              body.run();
            }
          });
          break;
        case CLOUD_WRITE:
          final IBranch branch = owner.getBranch();
          new PArea(branch).executeWrite(new Function0<Unit>() {
            public Unit invoke() {
              body.run();
              final IWriteTransaction t = branch.getWriteTransaction();
              Iterable<Long> detachedNodes = t.getChildren(ITree.ROOT_ID, ITree.DETACHED_NODES_ROLE);
              Sequence.fromIterable(detachedNodes).toListSequence().visitAll(new IVisitor<Long>() {
                public void visit(Long it) {
                  t.deleteNode(it);
                }
              });
              lastTreeAfterSync = t.getTree();
              return Unit.INSTANCE;
            }
          });
          break;
        case CLOUD_READ:
          new PArea(owner.getBranch()).executeRead(new Function0<Unit>() {
            public Unit invoke() {
              body.run();
              lastTreeAfterSync = owner.getBranch().getTransaction().getTree();
              return Unit.INSTANCE;
            }
          });
          break;
        default:
          throw new RuntimeException("Unknown lock type: " + type);
      }
    } finally {
      ListSequence.fromList(activeLocks).removeLastElement();
    }
  }

  public class FlushExecutor {
    private final Object asyncFlushLock = new Object();
    private Future<?> currentAsyncFlush;
    private final AtomicBoolean flushRequested = new AtomicBoolean(false);

    private synchronized Future<?> submitFlush() {
      synchronized (asyncFlushLock) {
        flushRequested.set(true);
        if (currentAsyncFlush != null) {
          if (currentAsyncFlush.isCancelled() || currentAsyncFlush.isDone()) {
            currentAsyncFlush = null;
          }
        }
        if (currentAsyncFlush == null) {
          currentAsyncFlush = SharedExecutors.FIXED.submit(new Runnable() {
            public void run() {
              while (flushRequested.getAndSet(false)) {
                doFlush();
              }
            }
          });
        }
        return currentAsyncFlush;
      }
    }

    public void flush() {
      try {
        check_kjxrbf_a0a0a6ib(submitFlush(), this);
      } catch (InterruptedException e) {
      } catch (TimeoutException e) {
      } catch (ExecutionException e) {
      }
    }
  }
  private static Object check_kjxrbf_a0a0a6ib(Future<?> checkedDotOperand, FlushExecutor checkedDotThisExpression) throws InterruptedException, ExecutionException, TimeoutException {
    if (null != checkedDotOperand) {
      return checkedDotOperand.get(3, TimeUnit.MINUTES);
    }
    return null;
  }
}
