package org.modelix.model.mpsplugin.history;

/*Generated by MPS */

import jetbrains.mps.ide.ui.tree.TextTreeNode;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.modelix.model.api.IBranch;
import org.modelix.model.api.INode;
import org.modelix.model.api.IConcept;
import org.modelix.model.area.PArea;
import kotlin.jvm.functions.Function0;
import kotlin.Unit;
import org.modelix.model.api.PNodeAdapter;
import org.modelix.model.mpsplugin.ModelServerConnection;
import jetbrains.mps.ide.ThreadUtils;
import org.modelix.model.mpsplugin.SharedExecutors;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.modelix.model.api.ITree;
import com.intellij.icons.AllIcons;
import org.modelix.model.mpsplugin.MPSNodeMapping;
import org.jetbrains.mps.openapi.model.SNode;
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter;
import org.jetbrains.mps.openapi.module.SRepository;
import org.modelix.model.mpsplugin.CommandHelper;
import org.modelix.model.area.ContextArea;
import org.modelix.model.mpsadapters.mps.MPSArea;
import org.apache.log4j.Level;
import jetbrains.mps.ide.icons.GlobalIconManager;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import javax.swing.tree.TreeNode;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ListSequence;

/**
 * This represents a single node inside the CloudView
 */
public class CloudNodeTreeNode extends TextTreeNode {
  private static final Logger LOG = LogManager.getLogger(CloudNodeTreeNode.class);

  private IBranch branch;
  private INode node;
  private IConcept concept;
  private boolean initialized;

  public CloudNodeTreeNode(IBranch branch, final INode node) {
    super("");
    this.branch = branch;
    this.node = node;
    new PArea(branch).executeRead(new Function0<Unit>() {
      public Unit invoke() {
        CloudNodeTreeNode.this.concept = node.getConcept();
        long nodeId = ((PNodeAdapter) node).getNodeId();
        setNodeIdentifier(Long.toString(nodeId));
        updateText();
        return Unit.INSTANCE;
      }
    });
  }

  @Override
  public boolean isInitialized() {
    return initialized;
  }

  @Override
  public void update() {
    doUpdate();
  }

  @Override
  public void doUpdate() {
    TreeModelUtil.clearChildren(this);
    initialized = false;
  }

  @Override
  public boolean isLeaf() {
    if (!(initialized)) {
      return false;
    }
    return super.isLeaf();
  }

  @Override
  protected void doUpdatePresentation() {
    super.doUpdatePresentation();
    updateText();
  }

  @Override
  protected void doInit() {
    super.doInit();
    initialized = true;
    updateText();
    updateChildren();
  }

  public INode getNode() {
    return this.node;
  }

  public IConcept getConcept() {
    return this.concept;
  }

  public IBranch getBranch() {
    return this.branch;
  }

  public ModelServerConnection getModelServer() {
    return check_s6g2x7_a0a62(getAncestor(RepositoryTreeNode.class), this);
  }

  public void setTextAndRepaint(String text) {
    TreeModelUtil.setTextAndRepaint(this, text);
  }

  public void updateText() {
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        LoadingIcon.apply(CloudNodeTreeNode.this);
      }
    });
    SharedExecutors.FIXED.execute(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Unit>() {
      public Unit invoke() {
        return new PArea(branch).executeRead(new Function0<Unit>() {
          public Unit invoke() {
            final Wrappers._T<String> newText = new Wrappers._T<String>("");
            String mappedMPSNodeID = null;
            final long nodeId = ((PNodeAdapter) node).getNodeId();
            if (nodeId == ITree.ROOT_ID) {
              newText.value = "ROOT #1";
              setIcon(AllIcons.Nodes.Folder);
            } else {
              final IConcept concept = node.getConcept();

              if (concept != null) {
                mappedMPSNodeID = MPSNodeMapping.mappedMpsNodeID(node);
                final SNode snode = NodeToSNodeAdapter.wrap(node);
                final SRepository mpsRepo = CommandHelper.getSRepository();
                if (mpsRepo == null) {
                  throw new IllegalStateException("repository should not be null");
                }
                mpsRepo.getModelAccess().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Unit>() {
                  public Unit invoke() {
                    return ContextArea.INSTANCE.withAdditionalContext(new MPSArea(mpsRepo), new Function0<Unit>() {
                      public Unit invoke() {
                        try {
                          newText.value = snode + " [" + concept.getLongName() + "]   #" + Long.toHexString(nodeId);
                        } catch (Exception ex) {
                          if (LOG.isEnabledFor(Level.ERROR)) {
                            LOG.error("Failed to update the text", ex);
                          }
                          newText.value = "!!!" + ex.getMessage();
                        }
                        try {
                          setIcon(GlobalIconManager.getInstance().getIconFor(snode));
                        } catch (Exception ex) {
                          if (LOG.isEnabledFor(Level.ERROR)) {
                            LOG.error("Failed to update the icon", ex);
                          }
                        }
                        return Unit.INSTANCE;
                      }
                    });
                  }
                }));
              } else {
                newText.value = "#" + nodeId;
              }
            }
            String role = node.getRoleInParent();
            if (role != null) {
              newText.value = role + " : " + newText.value;
            }
            if (mappedMPSNodeID != null) {
              newText.value = newText.value + " -> MPS(" + mappedMPSNodeID + ")";
            }
            ThreadUtils.runInUIThreadNoWait(new Runnable() {
              public void run() {
                setTextAndRepaint(newText.value);
              }
            });
            return Unit.INSTANCE;
          }
        });
      }
    }));
  }

  protected void updateChildren() {
    if (!(initialized)) {
      throw new RuntimeException();
    }

    final Map<INode, CloudNodeTreeNode> existing = MapSequence.fromMap(new LinkedHashMap<INode, CloudNodeTreeNode>(16, (float) 0.75, false));
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        if (Sequence.fromIterable(TreeModelUtil.getChildren(CloudNodeTreeNode.this)).isEmpty()) {
          TreeModelUtil.setChildren(CloudNodeTreeNode.this, Sequence.<TreeNode>singleton(LoadingIcon.apply(new TextTreeNode("loading ..."))));
        }
        Sequence.fromIterable(TreeModelUtil.getChildren(CloudNodeTreeNode.this)).ofType(CloudNodeTreeNode.class).visitAll(new IVisitor<CloudNodeTreeNode>() {
          public void visit(CloudNodeTreeNode it) {
            MapSequence.fromMap(existing).put(it.node, it);
          }
        });
      }
    });
    SharedExecutors.FIXED.execute(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Unit>() {
      public Unit invoke() {
        return new PArea(branch).executeRead(new Function0<Unit>() {
          public Unit invoke() {
            Iterable<INode> allChildren = node.getAllChildren();
            final List<CloudNodeTreeNode> newChildren = Sequence.fromIterable(allChildren).select(new ISelector<INode, CloudNodeTreeNode>() {
              public CloudNodeTreeNode select(INode it) {
                return (MapSequence.fromMap(existing).containsKey(it) ? MapSequence.fromMap(existing).get(it) : new CloudNodeTreeNode(branch, it));
              }
            }).toListSequence();
            ThreadUtils.runInUIThreadNoWait(new Runnable() {
              public void run() {
                TreeModelUtil.setChildren(CloudNodeTreeNode.this, ListSequence.fromList(newChildren).ofType(TreeNode.class));
                ListSequence.fromList(newChildren).visitAll(new IVisitor<CloudNodeTreeNode>() {
                  public void visit(CloudNodeTreeNode it) {
                    it.update();
                  }
                });
              }
            });
            return Unit.INSTANCE;
          }
        });
      }
    }));
  }
  private static ModelServerConnection check_s6g2x7_a0a62(RepositoryTreeNode checkedDotOperand, CloudNodeTreeNode checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelServer();
    }
    return null;
  }
}
