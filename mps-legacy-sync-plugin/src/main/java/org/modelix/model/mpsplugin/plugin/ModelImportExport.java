package org.modelix.model.mpsplugin.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.modelix.common.PropertyOrEnv;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.io.PrintWriter;
import java.net.Socket;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.StringWriter;
import org.modelix.model.mpsplugin.ModelServerConnection;
import org.modelix.model.mpsplugin.ModelServerConnections;
import java.util.function.Consumer;
import com.intellij.openapi.application.ApplicationManager;
import org.modelix.model.mpsplugin.ModelCloudExporter;
import jetbrains.mps.project.Project;
import java.util.List;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.StandaloneMPSProject;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.messages.IMessage;
import org.apache.log4j.Level;
import com.intellij.openapi.project.ProjectManager;
import org.modelix.model.lazy.RepositoryId;
import org.modelix.model.client.ActiveBranch;
import kotlin.jvm.functions.Function1;
import org.modelix.model.api.IWriteTransaction;
import org.modelix.model.api.ITree;
import org.modelix.model.api.IConcept;
import org.modelix.model.mpsadapters.mps.SConceptAdapter;
import org.modelix.model.mpsplugin.ProjectBinding;
import jetbrains.mps.project.MPSProject;
import org.modelix.model.mpsplugin.SyncDirection;
import org.modelix.model.mpsplugin.Binding;
import org.modelix.model.client.IModelClient;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class ModelImportExport {
  private static final Logger LOG = LogManager.getLogger(ModelImportExport.class);
  public void cloud2mps() {
    final String exportPath = PropertyOrEnv.get(ModelixExportConfiguration.PATH);
    System.out.println("Modelix Application Plugin - export path: " + exportPath);
    if ((exportPath == null || exportPath.length() == 0)) {
      System.err.println(ModelixExportConfiguration.PATH + " not provided");
      System.exit(1);
    }
    try {
      System.out.println("Modelix Application Plugin - Starting model export ...");
      System.setProperty(ModelixExportConfiguration.STARTED, "true");
      final String modelServerURL = PropertyOrEnv.get(ModelixExportConfiguration.SERVER_URL);

      System.out.println("Modelix Application Plugin - consider gradle task connection");
      String socketPortStr = PropertyOrEnv.get(ModelixExportConfiguration.GRADLE_PLUGIN_SOCKET_PORT);
      final Wrappers._T<PrintWriter> gradleTaskOut = new Wrappers._T<PrintWriter>();
      if (socketPortStr != null && !((socketPortStr == null || socketPortStr.length() == 0))) {
        System.out.println("Modelix Application Plugin - connecting to gradle task on port " + socketPortStr);
        int gradleTaskPort = Integer.parseInt(socketPortStr);
        Socket gradleTaskClient = new Socket("127.0.0.1", gradleTaskPort);
        gradleTaskOut.value = new PrintWriter(gradleTaskClient.getOutputStream(), true);
        BufferedReader gradleTaskIn = new BufferedReader(new InputStreamReader(gradleTaskClient.getInputStream()));
      } else {
        System.out.println("Modelix Application Plugin - connecting to gradle task not requested");
        StringWriter sw = new StringWriter();
        gradleTaskOut.value = new PrintWriter(sw, true);
      }
      System.out.println("Modelix Application Plugin - gradle task considered");

      ModelServerConnection modelServerConnection = ModelServerConnections.getInstance().ensureModelServerIsPresent(modelServerURL);
      System.out.println("Modelix Application Plugin - Waiting for Model Server Connection");
      modelServerConnection.whenConnected(new Consumer<ModelServerConnection>() {
        @Override
        public void accept(ModelServerConnection connection) {
          System.out.println("Modelix Application Plugin - Connected, starting ModelCloudExporter");
          ApplicationManager.getApplication().invokeLaterOnWriteThread(new Runnable() {
            @Override
            public void run() {
              ApplicationManager.getApplication().runWriteAction(new Runnable() {
                public void run() {
                  try {
                    final ModelCloudExporter modelCloudExporter = new ModelCloudExporter(modelServerURL, PropertyOrEnv.get(ModelixExportConfiguration.REPOSITORY_ID), PropertyOrEnv.get(ModelixExportConfiguration.BRANCH_NAME)).setCheckoutMode();
                    Consumer<Project> stuffToDoOnceWeGetAProject = new Consumer<Project>() {
                      @Override
                      public void accept(final Project mpsProject) {
                        System.out.println("Modelix Application Plugin - Got the project: " + mpsProject);

                        final Runnable runExport = new Runnable() {
                          @Override
                          public void run() {
                            ApplicationManager.getApplication().invokeLater(new Runnable() {
                              @Override
                              public void run() {
                                System.out.println("========================================================");
                                System.out.println("Modelix Application Plugin - Running the actual exporter");
                                System.out.println("========================================================");

                                mpsProject.getRepository().getModelAccess().executeCommand(new Runnable() {
                                  public void run() {
                                    try {
                                      modelCloudExporter.setCheckoutMode().export(exportPath, mpsProject);
                                      // Application.exit does not let us set a proper exit code, therefore we communicate
                                      // we failed or managed to export through strings...
                                      System.out.println("DOWNLOAD TASK WRITING " + "<MODEL EXPORT COMPLETED SUCCESSFULLY>\n");
                                      gradleTaskOut.value.println("<MODEL EXPORT COMPLETED SUCCESSFULLY>");
                                    } catch (Throwable t) {
                                      t.printStackTrace();
                                      System.out.println("CHECKOUT FAILED");
                                      // Application.exit does not let us set a proper exit code, therefore we communicate
                                      // we failed or managed to export through strings...
                                      System.out.println("DOWNLOAD TASK WRITING " + "<MODEL EXPORT NOT COMPLETED SUCCESSFULLY>\n");
                                      gradleTaskOut.value.println("<MODEL EXPORT NOT COMPLETED SUCCESSFULLY>");
                                    }
                                  }
                                });
                                System.setProperty(ModelixExportConfiguration.DONE, "true");
                                System.out.println("Starting shut down of Application");
                                ApplicationManager.getApplication().invokeLater(new Runnable() {
                                  @Override
                                  public void run() {
                                    ApplicationManager.getApplication().exit(true, true, false);
                                  }
                                });
                              }
                            });
                          }
                        };
                        final String make = PropertyOrEnv.get(ModelixExportConfiguration.MAKE);
                        if (make == null) {
                          System.out.println("Modelix Application Plugin - No need to run make");
                          runExport.run();
                        } else {
                          System.out.println("Modelix Application Plugin - Running make before export");
                          List<SModule> modulesToBuild = null;
                          if (Objects.equals(make, "all")) {
                            modulesToBuild = ListSequence.fromListWithValues(new ArrayList<SModule>(), (Iterable<SModule>) mpsProject.getProjectModules());
                          } else {
                            modulesToBuild = ListSequence.fromList(ListSequence.fromListWithValues(new ArrayList<SModule>(), (Iterable<SModule>) mpsProject.getProjectModules())).where(new IWhereFilter<SModule>() {
                              public boolean accept(SModule it) {
                                final String virtualFolder = ((StandaloneMPSProject) mpsProject).getFolderFor(it);
                                System.out.println("Modelix Application Plugin - Considering module: " + it.getModuleName() + " virtual folder: " + virtualFolder + ", make is currently: " + make);
                                return Sequence.fromIterable(Sequence.fromArray(make.split(","))).any(new IWhereFilter<String>() {
                                  public boolean accept(String it) {
                                    return Objects.equals(virtualFolder, it);
                                  }
                                });
                              }
                            }).toListSequence();
                          }
                          System.out.println("Modelix Application Plugin - Modules to be built: " + IterableUtils.join(ListSequence.fromList(modulesToBuild).select(new ISelector<SModule, String>() {
                            public String select(SModule it) {
                              return it.getModuleName();
                            }
                          }), ", "));
                          new ProjectMakeRunner().execute(mpsProject, false, modulesToBuild, new Consumer<Tuples._2<String, List<IMessage>>>() {
                            @Override
                            public void accept(Tuples._2<String, List<IMessage>> res) {
                              System.out.println("========================================================");
                              System.out.println("Modelix Application Plugin - Make completed successfully");
                              System.out.println("========================================================");

                              if (LOG.isDebugEnabled()) {
                                LOG.debug("Make messages:");
                              }
                              for (IMessage message : ListSequence.fromList(res._1())) {
                                if (LOG.isDebugEnabled()) {
                                  LOG.debug("  <MAKE> " + message.getKind() + " " + message.getText());
                                }
                              }
                              if (LOG.isInfoEnabled()) {
                                LOG.info("Make Project Success: " + res._0());
                              }

                              System.out.println("========================================================");
                              System.out.println("Modelix Application Plugin - Make completed successfully");
                              System.out.println("========================================================");

                              runExport.run();
                            }
                          }, new Consumer<Tuples._2<String, List<IMessage>>>() {
                            @Override
                            public void accept(Tuples._2<String, List<IMessage>> res) {
                              System.out.println("========================================");
                              System.out.println("Modelix Application Plugin - Make failed");
                              System.out.println("  make message should follow:");
                              System.out.println("========================================");

                              if (LOG.isDebugEnabled()) {
                                LOG.debug("Make messages:");
                              }
                              for (IMessage message : ListSequence.fromList(res._1())) {
                                if (LOG.isInfoEnabled()) {
                                  LOG.info("  <MAKE> " + message.getKind() + " " + message.getText());
                                }
                                System.out.println("  <MAKE> " + message.getKind() + " " + message.getText());
                              }
                              if (LOG.isEnabledFor(Level.WARN)) {
                                LOG.warn("Make Project Failure: " + res._0());
                              }

                              System.out.println("========================================");

                              // We try to export anyway
                              runExport.run();
                            }
                          });
                        }
                      }
                    };
                    ProjectManagerExtensions.withTheOnlyProject(ProjectManager.getInstance(), stuffToDoOnceWeGetAProject);
                  } catch (Exception ex) {
                    if (LOG.isEnabledFor(Level.ERROR)) {
                      LOG.error("Modelix Application Plugin Failure", ex);
                    }
                    // Application.exit does not let us set a proper exit code, therefore we communicate
                    // we failed or managed to export through strings...
                    System.out.println("<MODEL EXPORT NOT COMPLETED SUCCESSFULLY>");
                    ApplicationManager.getApplication().exit(true, true, false);
                  }
                }
              });
            }
          });
        }
      });
    } catch (Exception ex) {
      ex.printStackTrace();
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Modelix Application Plugin Failure", ex);
      }
      System.exit(1);
    }
  }

  public void mps2cloud() {
    try {
      System.out.println("Modelix Application Plugin - Starting model import ...");
      System.setProperty(ModelixImportConfiguration.STARTED, "true");
      String modelServerURL = PropertyOrEnv.get(ModelixImportConfiguration.SERVER_URL);
      ModelServerConnection modelServerConnection = ModelServerConnections.getInstance().ensureModelServerIsPresent(modelServerURL);
      System.out.println("Modelix Application Plugin - Waiting for Model Server Connection");
      modelServerConnection.whenConnected(new Consumer<ModelServerConnection>() {
        public void accept(final ModelServerConnection connection) {
          System.out.println("Modelix Application Plugin - Connected, starting model import");
          ApplicationManager.getApplication().invokeLaterOnWriteThread(new Runnable() {
            @Override
            public void run() {
              ApplicationManager.getApplication().runWriteAction(new Runnable() {
                public void run() {
                  try {
                    ProjectManagerExtensions.withTheOnlyProject(ProjectManager.getInstance(), new Consumer<Project>() {
                      public void accept(Project project) {
                        System.out.println("Project " + project.getName() + " opened");
                        for (SModule module : ListSequence.fromList(project.getProjectModules())) {
                          System.out.println("Project module: " + module.getModuleName());
                        }
                        RepositoryId repositoryId = new RepositoryId(PropertyOrEnv.get(ModelixImportConfiguration.REPOSITORY_ID));
                        ActiveBranch activeBranch = connection.getActiveBranch(repositoryId);
                        activeBranch.switchBranch(PropertyOrEnv.getOrElse(ModelixImportConfiguration.BRANCH_NAME, RepositoryId.DEFAULT_BRANCH));

                        long projectNodeId = activeBranch.getBranch().computeWriteT(new Function1<IWriteTransaction, Long>() {
                          public Long invoke(final IWriteTransaction t) {
                            Iterable<Long> allChildren = t.getAllChildren(ITree.ROOT_ID);
                            final IConcept projectConcept = SConceptAdapter.wrap(CONCEPTS.Project$An);
                            Long id = Sequence.fromIterable(allChildren).findFirst(new IWhereFilter<Long>() {
                              public boolean accept(Long it) {
                                return check_d5jcfl_a0a0a0a2a0a0a6a0a0a0a0a0a0a0a0a0a1a0a0f0a0c(t.getConcept(it), projectConcept);
                              }
                            });
                            if (id == null) {
                              id = t.addNewChild(ITree.ROOT_ID, "projects", -1, projectConcept);
                            }
                            return id;
                          }
                        });

                        final ProjectBinding binding = new ProjectBinding((MPSProject) project, projectNodeId, SyncDirection.TO_CLOUD);
                        connection.addBinding(repositoryId, binding, new Runnable() {
                          public void run() {
                            waitForWriteToModelServer(binding, connection.getClient(), new Runnable() {
                              public void run() {
                                System.out.println("<MODEL IMPORT COMPLETED SUCCESSFULLY>");
                                ApplicationManager.getApplication().invokeLater(new Runnable() {
                                  public void run() {
                                    ApplicationManager.getApplication().exit(true, true, false);
                                  }
                                });
                              }
                            });
                          }
                        });
                      }
                    });
                  } catch (Exception ex) {
                    if (LOG.isEnabledFor(Level.ERROR)) {
                      LOG.error("Modelix Application Plugin Failure", ex);
                    }
                    // Application.exit does not let us set a proper exit code, therefore we communicate
                    // we failed or managed to export through strings...
                    System.out.println("<MODEL IMPORT FAILED>");
                    ApplicationManager.getApplication().exit(true, true, false);
                  }
                }
              });
            }
          });
        }
      });
    } catch (Exception ex) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Modelix Application Plugin Failure", ex);
      }
      System.exit(1);
    }
  }

  private void waitForWriteToModelServer(final Binding binding, final IModelClient client, final Runnable whenDone) {
    ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
      public void run() {
        try {
          _FunctionTypes._return_P0_E0<? extends Boolean> condition = new _FunctionTypes._return_P0_E0<Boolean>() {
            public Boolean invoke() {
              return client.getPendingSize() == 0 && client.getAsyncStore().getPendingSize() == 0 && binding.isDone();
            }
          };
          while (true) {
            Thread.sleep(1000);
            if (!(condition.invoke())) {
              continue;
            }
            Thread.sleep(1000);
            if (!(condition.invoke())) {
              continue;
            }
            Thread.sleep(1000);
            if (!(condition.invoke())) {
              continue;
            }
            break;
          }
          whenDone.run();
        } catch (InterruptedException e) {
        }
      }
    });
  }
  private static boolean check_d5jcfl_a0a0a0a2a0a0a6a0a0a0a0a0a0a0a0a0a1a0a0f0a0c(IConcept checkedDotOperand, IConcept projectConcept) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.isSubConceptOf(projectConcept);
    }
    return false;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Project$An = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x37a0917d689de959L, "org.modelix.model.repositoryconcepts.structure.Project");
  }
}
