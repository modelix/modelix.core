package org.modelix.model.mpsplugin;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import javax.swing.Timer;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import jetbrains.mps.project.Project;
import java.util.List;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.apache.log4j.Level;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.ide.ThreadUtils;
import com.intellij.openapi.application.ApplicationManager;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.ModelAccess;
import jetbrains.mps.project.ProjectManager;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import jetbrains.mps.smodel.MPSModuleRepository;

public class CommandHelper {
  private static final Logger LOG = LogManager.getLogger(CommandHelper.class);

  private static Timer timer = new Timer(10, new ActionListener() {
    public void actionPerformed(ActionEvent e) {
      Project project = getProject();
      if (project == null) {
        return;
      }
      timer.stop();
      List<Tuples._2<Runnable, Boolean>> queueCopy = ListSequence.fromListWithValues(new ArrayList<Tuples._2<Runnable, Boolean>>(), queue);
      ListSequence.fromList(queue).clear();
      for (Tuples._2<Runnable, Boolean> entry : ListSequence.fromList(queueCopy)) {
        try {
          executeCommand(project.getRepository(), (boolean) entry._1(), entry._0());
        } catch (Exception ex) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("", ex);
          }
        }
      }
    }
  });
  private static List<Tuples._2<Runnable, Boolean>> queue = ListSequence.fromList(new ArrayList<Tuples._2<Runnable, Boolean>>());

  public static void runInCommand(Runnable runnable) {
    runInCommand(runnable, false);
  }

  public static void runInUndoTransparentCommand(Runnable runnable) {
    runInCommand(runnable, true);
  }

  public static void runInCommand(final Runnable runnable, final boolean undoTransparent) {
    final Project project = getProject();
    if (project == null) {
      ListSequence.fromList(queue).addElement(MultiTuple.<Runnable,Boolean>from(runnable, undoTransparent));
      if (!(timer.isRunning())) {
        timer.start();
      }
    } else {
      final Wrappers._T<Throwable> ex = new Wrappers._T<Throwable>(null);
      final Runnable runnableWithExceptionHandling = new Runnable() {
        public void run() {
          try {
            runnable.run();
          } catch (Throwable t) {
            ex.value = t;
          }
        }
      };
      if (ThreadUtils.isInEDT()) {
        executeCommand(project.getRepository(), undoTransparent, runnableWithExceptionHandling);
      } else {
        ApplicationManager.getApplication().invokeAndWait(new Runnable() {
          public void run() {
            executeCommand(project.getRepository(), undoTransparent, runnableWithExceptionHandling);
          }
        });
      }
      if (ex.value != null) {
        throw new RuntimeException("Exception in command", ex.value);
      }
    }
  }

  public static void executeCommand(SRepository repository, boolean undoTransparent, Runnable runnable) {
    ThreadUtils.assertEDT();

    ModelAccess modelAccess = repository.getModelAccess();
    if (modelAccess.canWrite()) {
      runnable.run();
    } else {
      if (undoTransparent) {
        modelAccess.executeUndoTransparentCommand(runnable);
      } else {
        modelAccess.executeCommand(runnable);
      }
    }
  }

  protected static Project getProject() {
    List<Project> projects = ProjectManager.getInstance().getOpenedProjects();
    return ListSequence.fromList(projects).first();
  }

  public static SRepository getSRepository() {
    List<Project> openedProjects = ProjectManager.getInstance().getOpenedProjects();
    SRepository projectRepo = ListSequence.fromList(openedProjects).select(new ISelector<Project, SRepository>() {
      public SRepository select(Project it) {
        return it.getRepository();
      }
    }).where((_FunctionTypes._return_P1_E0<Boolean, SRepository>) (_FunctionTypes._return_P1_E0) new NotNullWhereFilter()).first();
    return (projectRepo != null ? projectRepo : MPSModuleRepository.getInstance());
  }

}
