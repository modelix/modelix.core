package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.modelix.model.api.INode;
import org.modelix.model.api.PNodeAdapter;
import org.modelix.model.api.IConcept;
import org.modelix.model.mpsadapters.mps.SConceptAdapter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Objects;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import org.jetbrains.mps.openapi.language.SProperty;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.modelix.model.api.IProperty;
import org.modelix.model.api.IChildLink;
import org.modelix.model.api.IReferenceLink;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class INodeUtils {
  public INodeUtils() {
  }
  public static long nodeIdAsLong(final INode _this) {
    PNodeAdapter cloudProjectAsPNodeAdapter = ((PNodeAdapter) _this);
    long nodeId = cloudProjectAsPNodeAdapter.getNodeId();
    return nodeId;
  }
  public static INode containingModule(final INode _this) {
    if (INodeUtils.isModule(_this)) {
      return _this;
    }
    INode parent = _this.getParent();
    if (parent == null) {
      return null;
    }
    return INodeUtils.containingModule(parent);
  }
  public static INode containingModel(final INode _this) {
    if (INodeUtils.isModel(_this)) {
      return _this;
    }
    INode parent = _this.getParent();
    if (parent == null) {
      return null;
    }
    return INodeUtils.containingModel(parent);
  }
  public static boolean isModule(final INode _this) {
    IConcept concept = _this.getConcept();
    if (concept == null) {
      return false;
    }
    return concept.isSubConceptOf(SConceptAdapter.wrap(CONCEPTS.Module$4i));
  }
  public static boolean isModel(final INode _this) {
    IConcept concept = _this.getConcept();
    if (concept == null) {
      return false;
    }
    return concept.isSubConceptOf(SConceptAdapter.wrap(CONCEPTS.Model$2P));
  }
  public static INode findChildByName(final INode _this, String name) {
    for (INode child : Sequence.fromIterable(_this.getAllChildren())) {
      if (Objects.equals(child.getPropertyValue("name"), name)) {
        return child;
      }
    }
    return null;
  }
  public static List<INode> getChidlrenAsList(final INode _this, String role) {
    List<INode> nodes = ListSequence.fromList(new LinkedList<INode>());
    for (INode node : Sequence.fromIterable(_this.getChildren(role))) {
      ListSequence.fromList(nodes).addElement(node);
    }
    return nodes;
  }
  public static void removeAllChildrenWithRole(final INode _this, String role) {
    List<INode> nodes = ListSequence.fromList(new LinkedList<INode>());
    for (INode node : Sequence.fromIterable(_this.getChildren(role))) {
      ListSequence.fromList(nodes).addElement(node);
    }
    for (INode child : ListSequence.fromList(nodes)) {
      _this.removeChild(child);
    }
  }
  public static void copyProperty(final INode _this, INode original, String propertyName) {
    try {
      _this.setPropertyValue(propertyName, original.getPropertyValue(propertyName));
    } catch (Exception e) {
      throw new RuntimeException("Unable to copy property " + propertyName + " from " + original + " to " + _this, e);
    }
  }
  public static void copyProperty(final INode _this, INode original, SProperty property) {
    try {
      _this.setPropertyValue(property.getName(), original.getPropertyValue(property.getName()));
    } catch (Exception e) {
      throw new RuntimeException("Unable to copy property " + property.getName() + " from " + original + " to " + _this, e);
    }
  }
  public static void copyPropertyIfNecessary(final INode _this, INode original, SProperty property) {
    if (Objects.equals(original.getPropertyValue(property.getName()), _this.getPropertyValue(property.getName()))) {
      return;
    }
    INodeUtils.copyProperty(_this, original, property);
  }
  public static INode replicateChild(final INode _this, String role, INode original) {
    try {
      Map<INode, INode> equivalenceMap = MapSequence.fromMap(new HashMap<INode, INode>());
      List<Tuples._3<INode, String, INode>> postponedReferencesAssignments = ListSequence.fromList(new LinkedList<Tuples._3<INode, String, INode>>());
      INode result = INodeUtils.replicateChildHelper(_this, role, original, equivalenceMap, postponedReferencesAssignments);
      for (Tuples._3<INode, String, INode> postponedRefAssignment : ListSequence.fromList(postponedReferencesAssignments)) {
        INode target = postponedRefAssignment._2();
        if (MapSequence.fromMap(equivalenceMap).containsKey(target)) {
          target = MapSequence.fromMap(equivalenceMap).get(target);
        }
        postponedRefAssignment._0().setReferenceTarget(postponedRefAssignment._1(), target);
      }
      return result;
    } catch (Exception e) {
      throw new RuntimeException("Unable to replicate child in role " + role + ". Original: " + original + ", This: " + _this, e);
    }
  }
  public static void cloneChildren(final INode _this, INode original, String role) {
    INodeUtils.removeAllChildrenWithRole(_this, role);
    for (INode originalChild : Sequence.fromIterable(original.getChildren(role))) {
      INodeUtils.replicateChild(_this, role, originalChild);
    }
  }
  public static INode replicateChildHelper(final INode _this, String role, INode original, Map<INode, INode> equivalenceMap, List<Tuples._3<INode, String, INode>> postponedReferencesAssignments) {
    IConcept concept = original.getConcept();
    INode copy = null;
    try {
      copy = _this.addNewChild(role, -1, concept);
    } catch (Exception e) {
      throw new RuntimeException("Unable to add child to " + _this + " with role " + role + " and concept " + concept, e);
    }
    for (IProperty property : ListSequence.fromList(concept.getAllProperties())) {
      copy.setPropertyValue(property.getName(), original.getPropertyValue(property.getName()));
    }
    for (IChildLink childLink : ListSequence.fromList(concept.getAllChildLinks())) {
      for (INode child : ListSequence.fromList(INodeUtils.getChidlrenAsList(original, childLink.getName()))) {
        INodeUtils.replicateChildHelper(copy, childLink.getName(), child, equivalenceMap, postponedReferencesAssignments);
      }
    }
    for (IReferenceLink refLink : ListSequence.fromList(concept.getAllReferenceLinks())) {
      INode target = original.getReferenceTarget(refLink.getName());
      if (target != null) {
        ListSequence.fromList(postponedReferencesAssignments).addElement(MultiTuple.<INode,String,INode>from(copy, refLink.getName(), target));
      }
    }
    return copy;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Module$4i = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50fL, "org.modelix.model.repositoryconcepts.structure.Module");
    /*package*/ static final SConcept Model$2P = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, "org.modelix.model.repositoryconcepts.structure.Model");
  }
}
