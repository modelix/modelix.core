package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.modelix.model.lazy.RepositoryId;
import org.modelix.model.client.RestWebModelClient;
import java.util.Map;
import org.modelix.model.client.ActiveBranch;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.modelix.model.api.IBranchListener;
import com.intellij.util.messages.MessageBusConnection;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.project.ProjectManager;
import com.intellij.openapi.project.ProjectManagerListener;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.project.Project;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.Objects;
import jetbrains.mps.ide.project.ProjectHelper;
import kotlin.jvm.functions.Function0;
import org.modelix.common.InstanceJwtToken;
import org.modelix.model.mpsplugin.plugin.ModelixConfigurationSystemProperties;
import org.modelix.model.mpsplugin.plugin.EModelixExecutionMode;
import java.util.Arrays;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import kotlin.jvm.functions.Function2;
import kotlin.Unit;
import org.modelix.model.client.ConnectionListener;
import javax.swing.SwingUtilities;
import java.util.function.Supplier;
import org.apache.log4j.Level;
import org.modelix.common.AuthorOverride;
import org.jetbrains.mps.openapi.model.SNode;
import org.modelix.model.area.PArea;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.IListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.modelix.model.mpsadapters.mps.SNodeAPI;
import org.modelix.model.api.IBranch;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.ITransaction;
import org.modelix.model.api.ITree;
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter;
import org.modelix.model.api.PNodeAdapter;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.modelix.model.api.IWriteTransaction;
import org.modelix.model.mpsadapters.mps.SConceptAdapter;
import org.modelix.model.client.ReplicatedRepository;
import org.modelix.model.client.IModelClient;
import java.util.function.Consumer;
import de.q60.mps.incremental.runtime.DependencyBroadcaster;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SConcept;

public class ModelServerConnection {
  private static final Logger LOG = LogManager.getLogger(ModelServerConnection.class);
  private static final RepositoryId INFO_REPOSITORY_ID = new RepositoryId("info");
  public static final RepositoryId UI_STATE_REPOSITORY_ID = new RepositoryId("uistate");
  private String SETTINGS_KEY_PREFIX = ModelServerConnection.class.getName() + ".token/";

  public static final String DEFAULT_REPOSITORY_ID = "default";

  private String baseUrl;
  private RestWebModelClient client;
  private MpsReplicatedRepository infoTree;
  private final Map<RepositoryId, ActiveBranch> activeBranches = MapSequence.fromMap(new HashMap<RepositoryId, ActiveBranch>());
  private List<IListener> listeners = ListSequence.fromList(new ArrayList<IListener>());
  private String id;
  private String email;
  private Map<ActiveBranch, IBranchListener> invalidationListeners = MapSequence.fromMap(new HashMap<ActiveBranch, IBranchListener>());
  private MessageBusConnection messageBusConnection;
  private Map<RepositoryId, RootBinding> bindings = MapSequence.fromMap(new HashMap<RepositoryId, RootBinding>());

  public ModelServerConnection(String baseUrl) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("ModelServerConnection.init(" + baseUrl + ")");
    }
    messageBusConnection = ApplicationManager.getApplication().getMessageBus().connect();
    messageBusConnection.subscribe(ProjectManager.TOPIC, new ProjectManagerListener() {
      @Override
      public void projectClosing(@NotNull final Project closingProject) {
        for (ProjectBinding closingProjectBinding : Sequence.fromIterable(MapSequence.fromMap(bindings).values()).translate(new ITranslator2<RootBinding, Binding>() {
          public Iterable<Binding> translate(RootBinding it) {
            return it.getAllBindings();
          }
        }).ofType(ProjectBinding.class).where(new IWhereFilter<ProjectBinding>() {
          public boolean accept(ProjectBinding it) {
            return Objects.equals(ProjectHelper.toIdeaProject(it.getProject()), closingProject);
          }
        }).toListSequence()) {
          removeBinding(closingProjectBinding);
        }
      }
    });
    this.baseUrl = baseUrl;
    Function0<String> workspaceTokenProvider = new Function0<String>() {
      public String invoke() {
        return InstanceJwtToken.token;
      }
    };
    Function0<String> tokenProvider = (ModelixConfigurationSystemProperties.getExecutionMode() == EModelixExecutionMode.PROJECTOR ? workspaceTokenProvider : null);
    client = new RestWebModelClient(baseUrl, tokenProvider, Arrays.asList(new ConnectionListenerForForbiddenMessage(baseUrl)));
    final Wrappers._boolean connectedFirstTime = new Wrappers._boolean(true);
    client.addStatusListener(new Function2<RestWebModelClient.ConnectionStatus, RestWebModelClient.ConnectionStatus, Unit>() {
      public Unit invoke(RestWebModelClient.ConnectionStatus oldStatus, RestWebModelClient.ConnectionStatus newStatus) {
        if (newStatus == RestWebModelClient.ConnectionStatus.CONNECTED && connectedFirstTime.value) {
          connectedFirstTime.value = false;
          onConnect();
        }
        for (IListener l : ListSequence.fromList(listeners)) {
          l.connectionStatusChanged(newStatus == RestWebModelClient.ConnectionStatus.CONNECTED);
        }
        return Unit.INSTANCE;
      }
    });
  }

  /**
   * It seems that several connections are open at the same time: we do not want to show
   * error messages multiple times, so we use a shared state of the connection
   */
  private static class ConnectionListenerForForbiddenMessage implements ConnectionListener {
    private static Map<String, Boolean> inForbiddenStateByURL = MapSequence.fromMap(new HashMap<String, Boolean>());
    private String baseUrl;
    private ConnectionListenerForForbiddenMessage(String baseUrl) {
      this.baseUrl = baseUrl;
    }
    @Override
    public void receivedForbiddenResponse() {
      if (!(inForbiddenState())) {
        MapSequence.fromMap(inForbiddenStateByURL).put(baseUrl, true);
        SwingUtilities.invokeLater(new Runnable() {
          @Override
          public void run() {
            ModelixNotifications.notifyError("Forbidden Access", "Unauthorized to connect to Model Server " + baseUrl + ". Check you are logged in and have the right to access that Model Server");
          }
        });
      }
    }
    @Override
    public void receivedSuccessfulResponse() {
      MapSequence.fromMap(inForbiddenStateByURL).put(baseUrl, false);
    }

    private boolean inForbiddenState() {
      if (MapSequence.fromMap(inForbiddenStateByURL).containsKey(baseUrl)) {
        return MapSequence.fromMap(inForbiddenStateByURL).get(baseUrl);
      } else {
        return false;
      }
    }
  }

  public RootBinding getRootBinding(RepositoryId repositoryId) {
    RootBinding rootBinding = MapSequence.fromMap(bindings).get(repositoryId);
    if (rootBinding == null) {
      rootBinding = new RootBinding(this, repositoryId);
      MapSequence.fromMap(bindings).put(repositoryId, rootBinding);
    }
    return rootBinding;
  }

  @Deprecated
  public void reconnect() {
    client.reconnect();
  }

  private void onConnect() {
    id = client.get("server-id");
    if ((id == null || id.length() == 0)) {
      // TODO 'repositoryId' was renamed to 'server-id'. After migrating all servers this request is not required anymore.
      id = client.get("repositoryId");
    }
    if ((id == null || id.length() == 0)) {
      throw new RuntimeException(baseUrl + " doesn't provide an ID");
    }
    if (infoTree == null) {
      infoTree = new MpsReplicatedRepository(client, INFO_REPOSITORY_ID, ActiveBranch.DEFAULT_BRANCH_NAME, new Supplier<String>() {
        public String get() {
          return getAuthor();
        }
      });
    }
    try {
      email = client.getEmail();
    } catch (Exception ex) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Failed to read the users e-mail address", ex);
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("connected to " + baseUrl);
    }
  }

  public String getEmail() {
    return email;
  }

  public String getAuthor() {
    String email = getEmail();
    if (Objects.equals(email, "<no email>")) {
      email = null;
    }
    return AuthorOverride.apply(email);
  }

  public boolean isConnected() {
    RestWebModelClient.ConnectionStatus status = check_v06aqd_a0a0fb(client);
    return status != RestWebModelClient.ConnectionStatus.NEW && status != RestWebModelClient.ConnectionStatus.WAITING_FOR_TOKEN;
  }

  public String getId() {
    return this.id;
  }

  protected void checkConnected() {
    RestWebModelClient.ConnectionStatus connectionStatus = check_v06aqd_a0a0jb(client);
    if (connectionStatus != RestWebModelClient.ConnectionStatus.CONNECTED) {
      client.reconnect();
    }
    if (!(isConnected())) {
      throw new IllegalStateException("Not connected. Client is in status " + connectionStatus);
    }
  }

  public List<SNode> getAllRepositories() {
    return new PArea(getInfoBranch()).executeWrite(new Function0<List<SNode>>() {
      public List<SNode> invoke() {
        return SLinkOperations.getChildren(getInfo(), LINKS.repositories$b56J);
      }
    });
  }

  public int getAllRepositoriesCount() {
    return new PArea(getInfoBranch()).executeWrite(new Function0<Integer>() {
      public Integer invoke() {
        return ListSequence.fromList(SLinkOperations.getChildren(getInfo(), LINKS.repositories$b56J)).count();
      }
    });
  }

  public SNode getRepositoryInfoById(final String repositoryId) {
    SNode repositoryInfo = new PArea(getInfoBranch()).executeRead(new Function0<SNode>() {
      public SNode invoke() {
        SNode modelServerInfo = getInfo();
        return ListSequence.fromList(SLinkOperations.getChildren(modelServerInfo, LINKS.repositories$b56J)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return Objects.equals(SPropertyOperations.getString(it, PROPS.id$baYB), repositoryId);
          }
        });
      }
    });
    if (repositoryInfo == null) {
      List<String> knownRepositoryIds = new PArea(getInfoBranch()).executeRead(new Function0<IListSequence<String>>() {
        public IListSequence<String> invoke() {
          SNode modelServerInfo = getInfo();
          return ListSequence.fromList(SLinkOperations.getChildren(modelServerInfo, LINKS.repositories$b56J)).select(new ISelector<SNode, String>() {
            public String select(SNode it) {
              return SPropertyOperations.getString(it, PROPS.id$baYB);
            }
          }).toListSequence();
        }
      });

      throw new IllegalArgumentException("RepositoryInfo with ID " + repositoryId + " not found. Known repository ids: " + knownRepositoryIds);
    }
    return repositoryInfo;
  }

  public SNode addRepository(final String id) {
    return new PArea(getInfoBranch()).executeWrite(new Function0<SNode>() {
      public SNode invoke() {
        SNode modelServerInfo = getInfo();
        SNode repositoryInfo = SNodeOperations.cast(SNodeAPI.addNewChild(modelServerInfo, LINKS.repositories$b56J), CONCEPTS.RepositoryInfo$5Y);
        SPropertyOperations.assign(repositoryInfo, PROPS.id$baYB, id);
        SNode branchInfo = SNodeOperations.cast(SNodeAPI.addNewChild(repositoryInfo, LINKS.branches$b5_g), CONCEPTS.BranchInfo$6t);
        SPropertyOperations.assign(branchInfo, PROPS.name$MnvL, ActiveBranch.DEFAULT_BRANCH_NAME);
        return repositoryInfo;
      }
    });
  }

  public void removeRepository(final String id) {
    new PArea(getInfoBranch()).executeWrite(new Function0<SNode>() {
      public SNode invoke() {
        SNode info = getInfo();
        return SNodeOperations.deleteNode(ListSequence.fromList(SLinkOperations.getChildren(info, LINKS.repositories$b56J)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return Objects.equals(SPropertyOperations.getString(it, PROPS.id$baYB), id);
          }
        }));
      }
    });
  }

  public boolean hasProjectBinding(final RepositoryId repositoryId, final long projectNodeId) {
    return Sequence.fromIterable(getProjectBindings()).any(new IWhereFilter<ProjectBinding>() {
      public boolean accept(ProjectBinding it) {
        return Objects.equals(it.getCloudRepository().getRepositoryId(), repositoryId) && Objects.equals(it.getProjectNodeId(), projectNodeId);
      }
    });
  }

  public Iterable<ProjectBinding> getProjectBindings() {
    return Sequence.fromIterable(MapSequence.fromMap(bindings).values()).translate(new ITranslator2<RootBinding, Binding>() {
      public Iterable<Binding> translate(RootBinding it) {
        return it.getAllBindings();
      }
    }).ofType(ProjectBinding.class);
  }

  public void addBinding(RepositoryId repositoryId, final Binding binding, Runnable callback) {
    binding.setOwner(getRootBinding(repositoryId));
    binding.activate(callback);
  }

  public void addBinding(RepositoryId repositoryId, final Binding binding) {
    addBinding(repositoryId, binding, null);
  }

  public void removeBinding(Binding binding) {
    binding.deactivate(null);
    binding.setOwner(null);
  }

  public boolean hasModuleBinding(final RepositoryId repositoryId, final long moduleNodeId) {
    return Sequence.fromIterable(getModuleBindings()).any(new IWhereFilter<ModuleBinding>() {
      public boolean accept(ModuleBinding it) {
        return Objects.equals(it.getCloudRepository().getRepositoryId(), repositoryId) && Objects.equals(it.getModuleNodeId(), moduleNodeId);
      }
    });
  }
  public List<ModuleBinding> getModuleBinding(final RepositoryId repositoryId, final long moduleNodeId) {
    return Sequence.fromIterable(getModuleBindings()).where(new IWhereFilter<ModuleBinding>() {
      public boolean accept(ModuleBinding it) {
        return Objects.equals(it.getCloudRepository().getRepositoryId(), repositoryId) && Objects.equals(it.getModuleNodeId(), moduleNodeId);
      }
    }).toListSequence();
  }

  public Iterable<ModuleBinding> getModuleBindings() {
    return Sequence.fromIterable(MapSequence.fromMap(bindings).values()).translate(new ITranslator2<RootBinding, Binding>() {
      public Iterable<Binding> translate(RootBinding it) {
        return it.getAllBindings();
      }
    }).ofType(ModuleBinding.class);
  }

  public IBranch getInfoBranch() {
    checkConnected();
    return check_v06aqd_a1a26(infoTree);
  }
  public <T> T computeRead(final RepositoryId repositoryId, final Function0<T> producer) {
    return this.getInfoBranch().computeRead(new Function0<T>() {
      public T invoke() {
        ActiveBranch activeBranch = ModelServerConnection.this.getActiveBranch(repositoryId);
        final IBranch branch = activeBranch.getBranch();
        return new PArea(branch).executeRead(new Function0<T>() {
          public T invoke() {
            return producer.invoke();
          }
        });
      }
    });
  }

  @Nullable
  public SNode getInfo() {
    if (infoTree == null) {
      return null;
    }
    checkConnected();
    SNode result = new PArea(infoTree.getBranch()).executeRead(new Function0<SNode>() {
      public SNode invoke() {
        ITransaction t = infoTree.getBranch().getTransaction();
        Iterable<Long> allChildren_ = t.getAllChildren(ITree.ROOT_ID);
        Iterable<SNode> allChildren = Sequence.fromIterable(allChildren_).select(new ISelector<Long, SNode>() {
          public SNode select(Long it) {
            return (SNode) NodeToSNodeAdapter.wrap(new PNodeAdapter(it, infoTree.getBranch()));
          }
        });
        return Sequence.fromIterable(SNodeOperations.ofConcept(allChildren, CONCEPTS.ModelServerInfo$5v)).first();
      }
    });
    if (result == null) {
      SharedExecutors.FIXED.submit(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<SNode>() {
        public SNode invoke() {
          return new PArea(infoTree.getBranch()).executeWrite(new Function0<SNode>() {
            public SNode invoke() {
              IWriteTransaction t = infoTree.getBranch().getWriteTransaction();
              long id = t.addNewChild(ITree.ROOT_ID, "info", -1, SConceptAdapter.wrap(CONCEPTS.ModelServerInfo$5v));
              SNode repoInfo = SNodeOperations.cast(NodeToSNodeAdapter.wrap(new PNodeAdapter(id, infoTree.getBranch())), CONCEPTS.ModelServerInfo$5v);

              addRepository(DEFAULT_REPOSITORY_ID);

              return repoInfo;
            }
          });
        }
      }));
    }
    return result;
  }

  public ActiveBranch getActiveBranch(RepositoryId repositoryId) {
    checkConnected();
    synchronized (activeBranches) {
      ActiveBranch ab = MapSequence.fromMap(activeBranches).get(repositoryId);
      if (ab == null) {
        ab = new ActiveBranch(client, repositoryId, null, new Function0<String>() {
          public String invoke() {
            return getAuthor();
          }
        }) {
          @NotNull
          @Override
          protected ReplicatedRepository createReplicatedRepository(@NotNull IModelClient client, @NotNull RepositoryId repositoryId, @NotNull String branchName, @NotNull final Function0<String> user) {
            return new MpsReplicatedRepository(client, repositoryId, branchName, new Supplier<String>() {
              public String get() {
                return user.invoke();
              }
            });
          }
        };
        InvalidationBranchListener invalidationListener = new InvalidationBranchListener(ab);
        MapSequence.fromMap(invalidationListeners).put(ab, invalidationListener);
        ab.addListener(invalidationListener);
        MapSequence.fromMap(activeBranches).put(repositoryId, ab);
      }
      return ab;
    }
  }

  public Iterable<ActiveBranch> getActiveBranches() {
    synchronized (activeBranches) {
      return Sequence.fromIterable(MapSequence.fromMap(activeBranches).values()).toListSequence();
    }
  }

  public synchronized void dispose() {
    try {
      messageBusConnection.disconnect();
    } catch (Exception ex) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("", ex);
      }
    }
    try {
      check_v06aqd_a0a1a17(client);
    } catch (Exception ex) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("", ex);
      }
    }
    try {
      check_v06aqd_a0a2a17(infoTree);
    } catch (Exception ex) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("", ex);
      }
    }

    for (RootBinding binding : Sequence.fromIterable(MapSequence.fromMap(bindings).values())) {
      binding.deactivate(null);
    }
    synchronized (activeBranches) {
      for (ActiveBranch ab : Sequence.fromIterable(MapSequence.fromMap(activeBranches).values())) {
        try {
          IBranchListener invalidationListener = MapSequence.fromMap(invalidationListeners).removeKey(ab);
          if (invalidationListener != null) {
            ab.removeListener(invalidationListener);
          }
          ab.dispose();
        } catch (Exception ex) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("", ex);
          }
        }
      }
      MapSequence.fromMap(activeBranches).clear();
    }
  }

  public String getBaseUrl() {
    return baseUrl;
  }

  public IModelClient getClient() {
    checkConnected();
    return this.client;
  }

  @Override
  public String toString() {
    return baseUrl;
  }

  public void addListener(IListener l) {
    List<IListener> newListeners = ListSequence.fromListWithValues(new ArrayList<IListener>(), listeners);
    ListSequence.fromList(newListeners).addElement(l);
    listeners = newListeners;
  }

  public void removeListener(IListener l) {
    List<IListener> newListeners = ListSequence.fromListWithValues(new ArrayList<IListener>(), listeners);
    ListSequence.fromList(newListeners).removeElement(l);
    listeners = newListeners;
  }

  public void whenConnected(final Consumer<ModelServerConnection> consumer) {
    if (this.isConnected()) {
      consumer.accept(this);
    } else {
      final IListener listener = new IListener() {
        @Override
        public void connectionStatusChanged(boolean connected) {
          if (connected) {
            consumer.accept(ModelServerConnection.this);
            ModelServerConnection.this.removeListener(this);
          }
        }
      };
      this.addListener(listener);
    }
  }

  public interface IListener {
    default void connectionStatusChanged(boolean connected) {
    }
    default void bindingAdded(Binding binding) {
    }
    default void bindingRemoved(Binding binding) {
    }
    default void bindingActivated(Binding binding) {
    }
    default void bindingDeactivated(Binding binding) {
    }
  }

  public class InvalidationBranchListener implements IBranchListener {
    private ActiveBranch branch;
    public InvalidationBranchListener(ActiveBranch branch) {
      this.branch = branch;
    }
    @Override
    public void treeChanged(@Nullable ITree oldTree, @NotNull ITree newTree) {
      if (oldTree == null) {
        return;
      }
      TreeChangesCollector changesCollector = new TreeChangesCollector(branch.getBranch());
      newTree.visitChanges(oldTree, changesCollector);
      DependencyBroadcaster.INSTANCE.dependenciesChanged(changesCollector.getChanges());
    }
  }
  private static RestWebModelClient.ConnectionStatus check_v06aqd_a0a0fb(RestWebModelClient checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getConnectionStatus();
    }
    return null;
  }
  private static RestWebModelClient.ConnectionStatus check_v06aqd_a0a0jb(RestWebModelClient checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getConnectionStatus();
    }
    return null;
  }
  private static IBranch check_v06aqd_a1a26(MpsReplicatedRepository checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getBranch();
    }
    return null;
  }
  private static void check_v06aqd_a0a1a17(RestWebModelClient checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.dispose();
    }

  }
  private static void check_v06aqd_a0a2a17(MpsReplicatedRepository checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.dispose();
    }

  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink repositories$b56J = MetaAdapterFactory.getContainmentLink(0xb6980ebdf01d459dL, 0xa95238740f6313b4L, 0x62b7d9b07cecbcbfL, 0x62b7d9b07cecbcc2L, "repositories");
    /*package*/ static final SContainmentLink branches$b5_g = MetaAdapterFactory.getContainmentLink(0xb6980ebdf01d459dL, 0xa95238740f6313b4L, 0x62b7d9b07cecbcc0L, 0x62b7d9b07cecbcc4L, "branches");
  }

  private static final class PROPS {
    /*package*/ static final SProperty id$baYB = MetaAdapterFactory.getProperty(0xb6980ebdf01d459dL, 0xa95238740f6313b4L, 0x62b7d9b07cecbcc0L, 0x62b7d9b07cecbcc6L, "id");
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept RepositoryInfo$5Y = MetaAdapterFactory.getConcept(0xb6980ebdf01d459dL, 0xa95238740f6313b4L, 0x62b7d9b07cecbcc0L, "org.modelix.model.runtimelang.structure.RepositoryInfo");
    /*package*/ static final SConcept BranchInfo$6t = MetaAdapterFactory.getConcept(0xb6980ebdf01d459dL, 0xa95238740f6313b4L, 0x62b7d9b07cecbcc1L, "org.modelix.model.runtimelang.structure.BranchInfo");
    /*package*/ static final SConcept ModelServerInfo$5v = MetaAdapterFactory.getConcept(0xb6980ebdf01d459dL, 0xa95238740f6313b4L, 0x62b7d9b07cecbcbfL, "org.modelix.model.runtimelang.structure.ModelServerInfo");
  }
}
