package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.modelix.model.api.IBranch;
import org.jetbrains.mps.openapi.model.SModel;
import org.modelix.model.api.ITree;
import org.modelix.model.lazy.IBulkTree;
import org.modelix.model.lazy.PrefetchCache;
import kotlin.jvm.functions.Function0;
import kotlin.Unit;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Level;
import org.modelix.model.area.PArea;
import org.modelix.model.api.IWriteTransaction;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import org.modelix.model.api.ITransaction;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.modelix.model.api.IConcept;
import org.modelix.model.mpsadapters.mps.SConceptAdapter;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.modelix.model.api.INode;
import org.modelix.model.api.IProperty;
import org.modelix.model.api.INodeReference;
import org.jetbrains.mps.openapi.module.SRepository;
import org.modelix.model.area.IArea;
import org.modelix.model.area.CompositeArea;
import org.modelix.model.mpsadapters.mps.MPSArea;
import org.modelix.model.api.PNodeAdapter;
import org.modelix.model.api.NodeUtilKt;
import org.modelix.model.mpsadapters.mps.NodeToSNodeAdapter;
import java.util.Objects;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.util.IterableUtil;
import java.util.List;
import java.util.HashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.mps.openapi.language.SConcept;
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.event.SNodeAddEvent;
import org.jetbrains.mps.openapi.event.SNodeRemoveEvent;
import org.jetbrains.mps.openapi.event.SReferenceChangeEvent;
import jetbrains.mps.project.ModelImporter;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class ModelSynchronizer {
  private static final Logger LOG = LogManager.getLogger(ModelSynchronizer.class);
  public static final String USED_DEVKITS = "usedDevkits";
  public static final String MPS_NODE_ID_PROPERTY_NAME = "#mpsNodeId#";

  protected NodeMap nodeMap = new NodeMap(new NodeMap.BranchProvider() {
    public IBranch getBranch() {
      return ModelSynchronizer.this.getBranch();
    }
  });
  protected SModel model;
  protected long modelNodeId;
  private ICloudRepository cloudRepository;
  private final PendingReferences pendingReferences = new PendingReferences();

  public ModelSynchronizer(long modelNodeId, SModel model, ICloudRepository cloudRepository) {
    this.model = model;
    this.modelNodeId = modelNodeId;
    this.cloudRepository = cloudRepository;
  }

  public IBranch getBranch() {
    return cloudRepository.getBranch();
  }

  public void prefetchModelContent(ITree tree) {
    if (tree instanceof IBulkTree) {
      ((IBulkTree) tree).getDescendants(modelNodeId, true);
    }
  }

  public void runAndFlushReferences(Runnable runnable) {
    pendingReferences.runAndFlush(runnable);
  }

  public void syncModelToMPS(final ITree tree, final boolean withInitialRemoval) {
    PrefetchCache.Companion.with(tree, new Function0<Unit>() {
      public Unit invoke() {
        if (LOG.isTraceEnabled()) {
          LOG.trace("syncModel initialRemoval=" + withInitialRemoval + " on model " + model.getName().getLongName());
        }
        if (withInitialRemoval) {
          for (SNode root : ListSequence.fromList(ListSequence.fromListWithValues(new ArrayList<SNode>(), model.getRootNodes())).ofType(SNode.class)) {
            ListSequence.fromList(SNodeOperations.getChildren(root)).visitAll(new IVisitor<SNode>() {
              public void visit(SNode it) {
                SNodeOperations.deleteNode(it);
              }
            });
          }
        }
        pendingReferences.runAndFlush(new Runnable() {
          public void run() {
            prefetchModelContent(tree);
            syncRootNodesToMPS();
            syncModelPropertiesToMPS(tree);
          }
        });
        return Unit.INSTANCE;
      }
    });
  }

  public void syncModelPropertiesToMPS(ITree tree) {
    ModelPropertiesSynchronizer.syncModelPropertiesToMPS(tree, model, modelNodeId, cloudRepository);
  }

  public void fullSyncFromMPS() {
    final ITree tree = getBranch().getTransaction().getTree();
    if (!(tree.containsNode(modelNodeId))) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Skipping sync for " + this + ", because the model node " + Long.toHexString(modelNodeId) + " doesn't exist in the cloud model");
      }
      return;
    }
    PrefetchCache.Companion.with(tree, new Function0<Unit>() {
      public Unit invoke() {
        pendingReferences.runAndFlush(new Runnable() {
          public void run() {
            prefetchModelContent(tree);
            syncModelPropertiesFromMPS();
            syncRootNodesFromMPS();
          }
        });
        return Unit.INSTANCE;
      }
    });
    new PArea(getBranch()).executeWrite(new Function0<Unit>() {
      public Unit invoke() {
        return Unit.INSTANCE;
      }
    });
  }

  protected void syncRootNodesFromMPS() {
    IWriteTransaction t = getBranch().getWriteTransaction();
    Map<Long, SNode> syncedNodes = createChildrenSynchronizer(modelNodeId, LINKS.rootNodes$jxXY.getName()).syncToCloud(t);
    for (IMapping<Long, SNode> syncedNode : MapSequence.fromMap(syncedNodes)) {
      syncNodeFromMPS(syncedNode.value(), true);
    }
  }

  protected void syncRootNodesToMPS() {
    ITransaction t = getBranch().getTransaction();
    Map<Long, SNode> syncedNodes = createChildrenSynchronizer(modelNodeId, LINKS.rootNodes$jxXY.getName()).syncToMPS(t.getTree());
    for (IMapping<Long, SNode> syncedNode : MapSequence.fromMap(syncedNodes)) {
      syncNodeToMPS(syncedNode.key(), t.getTree(), true);
    }
  }

  public void syncModelPropertiesFromMPS() {
    new ModelPropertiesSynchronizer(modelNodeId, model, cloudRepository).syncModelPropertiesFromMPS();
  }

  public void syncUsedLanguagesAndDevKitsFromMPS() {
    new ModelPropertiesSynchronizer(modelNodeId, model, cloudRepository).syncUsedLanguagesAndDevKitsFromMPS();
  }

  public void syncModelImportsFromMPS() {
    new ModelPropertiesSynchronizer(modelNodeId, model, cloudRepository).syncModelImportsFromMPS();
  }

  protected SNode getOrCreateMPSNode(final long nodeId, final ITree tree) {
    if (nodeId == 0L || nodeId == ITree.ROOT_ID) {
      throw new RuntimeException("Invalid ID " + nodeId);
    }
    return nodeMap.getOrCreateNode(nodeId, new _FunctionTypes._return_P0_E0<SAbstractConcept>() {
      public SAbstractConcept invoke() {
        IConcept concept = tree.getConcept(nodeId);
        if (concept == null) {
          throw new RuntimeException("Node has no concept: " + nodeId);
        }
        SAbstractConcept sconcept = SConceptAdapter.unwrap(concept);
        if (sconcept == null) {
          throw new RuntimeException("Node has no MPS concept: " + nodeId + ", " + concept);
        }
        return sconcept;
      }
    });
  }

  public void syncNodeToMPS(long nodeId, ITree tree, boolean includeDescendants) {
    if (LOG.isTraceEnabled()) {
      LOG.trace("syncNode nodeId: " + nodeId);
    }
    try {
      final SAbstractConcept concept = SConceptAdapter.unwrap(tree.getConcept(nodeId));

      if (concept == null) {
        throw new RuntimeException("Node has no concept: " + Long.toHexString(nodeId) + ". Role: " + tree.getRole(nodeId) + ", Concept: " + tree.getConcept(nodeId));
      }
      SNode node = nodeMap.getOrCreateNode(nodeId, new _FunctionTypes._return_P0_E0<SAbstractConcept>() {
        public SAbstractConcept invoke() {
          return concept;
        }
      });
      for (SProperty property : CollectionSequence.fromCollection(concept.getProperties())) {
        node.setProperty(property, tree.getProperty(nodeId, property.getName()));
      }
      for (SReferenceLink link : CollectionSequence.fromCollection(concept.getReferenceLinks())) {
        syncReferenceToMPS(nodeId, link.getName(), tree);
      }
    } catch (Exception ex) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Failed to sync node " + nodeId, ex);
      }
    }
    syncChildrenToMPS(nodeId, tree, includeDescendants);
  }

  public void syncPropertyToMPS(long nodeId, String role, ITree tree) {
    SAbstractConcept concept = SConceptAdapter.unwrap(tree.getConcept(nodeId));
    SNode mpsNode = getOrCreateMPSNode(nodeId, tree);
    SProperty mpsProperty = findProperty(concept, role);
    mpsNode.setProperty(mpsProperty, tree.getProperty(nodeId, role));
  }

  public void syncProperties(INode source, INode target) {
    for (IProperty property : ListSequence.fromList(target.getConcept().getAllProperties())) {
      target.setPropertyValue(property.getName(), source.getPropertyValue(property.getName()));
    }
  }

  public void syncReferenceToMPS(final long nodeId, final String role, final ITree tree) {
    pendingReferences.add(new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        try {
          SNode node = getOrCreateMPSNode(nodeId, tree);
          INodeReference target = tree.getReferenceTarget(nodeId, role);

          SRepository repo = model.getRepository();
          IArea resolveContext = null;
          if (repo == null) {
            // We look in NodeMap instead
            resolveContext = new CompositeArea(new PArea(getBranch()), nodeMap);
          } else {
            resolveContext = new CompositeArea(new PArea(getBranch()), new MPSArea(repo), nodeMap);
          }
          INode targetNode = check_l95w85_a0g0a0a0a0a14(target, resolveContext);
          SNode targetSNode;
          PNodeAdapter targetAsPNodeAdapter = null;
          if (targetNode != null) {
            targetNode = NodeUtilKt.deepUnwrapNode(targetNode);
          }
          if (targetNode instanceof PNodeAdapter) {
            targetAsPNodeAdapter = (PNodeAdapter) targetNode;
          }
          if (targetAsPNodeAdapter == null) {
            targetSNode = NodeToSNodeAdapter.wrap(targetNode, repo);
          } else {
            long targetId = (targetAsPNodeAdapter == null ? 0L : targetAsPNodeAdapter.getNodeId());
            targetSNode = (targetId == 0L ? null : getOrCreateMPSNode(targetId, tree));
          }
          SReferenceLink link = findReferenceLink(node.getConcept(), role);
          node.setReferenceTarget(link, targetSNode);
          return targetSNode;
        } catch (RuntimeException e) {
          throw new RuntimeException("issue in syncReference, nodeId " + nodeId + ", role " + role, e);
        }
      }
    });
  }

  public void syncChildrenToMPS(long nodeId, ITree tree, boolean includeDescendants) {
    for (String linkName : tree.getChildRoles(nodeId)) {
      syncChildrenToMPS(nodeId, linkName, tree, includeDescendants);
    }
  }

  public void syncChildrenToMPS(final long parentId, final String role, ITree tree, boolean includeDescendants) {
    if (LOG.isTraceEnabled()) {
      LOG.trace("syncChildren nodeId:" + parentId + ", role:" + role + ", descendants? " + includeDescendants);
    }
    Map<Long, SNode> syncedNodes = createChildrenSynchronizer(parentId, role).syncToMPS(tree);

    // order
    boolean isRootNodes = parentId == modelNodeId && Objects.equals(role, LINKS.rootNodes$jxXY.getName());
    if (!(isRootNodes)) {
      SNode parentNode = nodeMap.getNode(parentId);
      SContainmentLink link = findContainmentLink(SNodeOperations.getConcept(parentNode), role);
      int index = 0;
      for (Long expectedId : Sequence.fromIterable(IterableUtil.asIterable(tree.getChildren(parentId, role).iterator()))) {
        SNode expectedNode = nodeMap.getNode(expectedId);
        SNode actualNode = ListSequence.fromList(SNodeOperations.getChildren(parentNode, link)).getElement(index);
        if (!(Objects.equals(actualNode, expectedNode))) {
          SNodeOperations.deleteNode(expectedNode);
          ListSequence.fromList(SNodeOperations.getChildren(parentNode, link)).insertElement(index, expectedNode);
        }
        index++;
      }
    }

    if (includeDescendants) {
      for (long childCloudId : MapSequence.fromMap(syncedNodes).keySet()) {
        syncNodeToMPS(childCloudId, tree, includeDescendants);
      }
    }
  }

  private Synchronizer<SNode> createChildrenSynchronizer(final long parentId, final String role) {
    return new Synchronizer<SNode>(parentId, role) {
      @Override
      public Map<Long, SNode> associate(ITree tree, List<Long> cloudChildren, List<SNode> mpsChildren, SyncDirection direction) {
        final Map<String, SNode> mpsIdToNode = MapSequence.fromMap(new HashMap<String, SNode>());
        ListSequence.fromList(mpsChildren).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            MapSequence.fromMap(mpsIdToNode).put(it.getNodeId().toString(), it);
          }
        });
        Set<SNode> mpsChildrenSet = SetSequence.fromSetWithValues(new HashSet<SNode>(), mpsChildren);
        Set<Long> cloudChildrenSet = SetSequence.fromSetWithValues(new HashSet<Long>(), cloudChildren);

        Map<Long, SNode> mapping = MapSequence.fromMap(new HashMap<Long, SNode>());
        for (long cloudChild : cloudChildren) {
          SNode mpsChild = nodeMap.getNode(cloudChild);
          if (mpsChild == null) {
            String persistedMpsId = tree.getProperty(cloudChild, MPS_NODE_ID_PROPERTY_NAME);
            if (persistedMpsId != null) {
              mpsChild = MapSequence.fromMap(mpsIdToNode).get(persistedMpsId);
              nodeMap.put(cloudChild, mpsChild);
            }
          }
          if (mpsChild != null && SetSequence.fromSet(mpsChildrenSet).contains(mpsChild)) {
            MapSequence.fromMap(mapping).put(cloudChild, mpsChild);
          }
        }
        for (SNode mpsChild : ListSequence.fromList(mpsChildren)) {
          long cloudChild = nodeMap.getId(mpsChild);
          if (cloudChild != 0L && tree.containsNode(cloudChild) && SetSequence.fromSet(cloudChildrenSet).contains(cloudChild)) {
            MapSequence.fromMap(mapping).put(cloudChild, mpsChild);
          }
        }
        return mapping;
      }
      @Override
      public long createCloudChild(IWriteTransaction t, SNode mpsChild) {
        long nodeId = getOrCreateCloudNode(mpsChild, parentId, role);
        if (t.getParent(nodeId) != parentId || t.getRole(nodeId) != role) {
          t.moveChild(parentId, role, -1, nodeId);
        }
        return nodeId;
      }
      @Override
      protected SNode createMPSChild(ITree tree, long cloudChildId) {
        SNode newNode = getOrCreateMPSNode(cloudChildId, tree);
        if (isRootNodes()) {
          model.addRootNode(newNode);
        } else {
          SNode parentMPSNode = nodeMap.getNode(tree.getParent(cloudChildId));
          ListSequence.fromList(SNodeOperations.getChildren(parentMPSNode, findContainmentLink(SNodeOperations.getConcept(parentMPSNode), role))).addElement(newNode);
        }
        return newNode;
      }
      @Override
      protected Iterable<SNode> getMPSChildren() {
        if (isRootNodes()) {
          return model.getRootNodes();
        } else {
          SNode parentNode = nodeMap.getNode(parentId);
          if (parentNode == null) {
            throw new IllegalStateException("Node has no parent but it is not a root node");
          }
          Iterable<? extends SNode> children = parentNode.getChildren(findContainmentLink(parentNode.getConcept(), role));
          return Sequence.fromIterable(children).ofType(SNode.class);
        }
      }
      private boolean isRootNodes() {
        return parentId == modelNodeId && Objects.equals(role, LINKS.rootNodes$jxXY.getName());
      }
      @Override
      public void removeMPSChild(SNode mpsChild) {
        SNodeOperations.deleteNode(mpsChild);
      }
    };
  }

  public SContainmentLink findContainmentLink(SAbstractConcept concept, final String linkName) {
    Iterable<SContainmentLink> links = concept.getContainmentLinks();
    SContainmentLink link = Sequence.fromIterable(links).findFirst(new IWhereFilter<SContainmentLink>() {
      public boolean accept(SContainmentLink it) {
        return Objects.equals(it.getName(), linkName);
      }
    });
    if (link == null) {
      throw new RuntimeException(concept + "." + linkName + " not found");
    }
    return link;
  }
  public SReferenceLink findReferenceLink(SAbstractConcept concept, final String linkName) {
    Iterable<SReferenceLink> links = concept.getReferenceLinks();
    SReferenceLink link = Sequence.fromIterable(links).findFirst(new IWhereFilter<SReferenceLink>() {
      public boolean accept(SReferenceLink it) {
        return Objects.equals(it.getName(), linkName);
      }
    });
    if (link == null) {
      throw new RuntimeException(concept + "." + linkName + " not found");
    }
    return link;
  }
  public SProperty findProperty(SAbstractConcept concept, final String role) {
    Iterable<SProperty> properties = concept.getProperties();
    SProperty property = Sequence.fromIterable(properties).findFirst(new IWhereFilter<SProperty>() {
      public boolean accept(SProperty it) {
        return Objects.equals(it.getName(), role);
      }
    });
    if (property == null) {
      throw new RuntimeException(concept + "." + role + " not found");
    }
    return property;
  }

  public void syncNodeFromMPS(final SNode parentNode, boolean includeDescendants) {
    if (parentNode.getModel() != model) {
      throw new RuntimeException("Not part of this model: " + parentNode);
    }
    final IBranch branch = getBranch();
    final IWriteTransaction t = branch.getWriteTransaction();
    final SConcept concept = parentNode.getConcept();

    final long parentNodeId = getOrCreateCloudNode(parentNode);

    INode cloudNode = new PNodeAdapter(parentNodeId, branch);
    MPSNodeMapping.mapToMpsNode(cloudNode, parentNode);

    for (SProperty property : CollectionSequence.fromCollection(concept.getProperties())) {
      String oldValue = t.getProperty(parentNodeId, property.getName());
      String newValue = parentNode.getProperty(property);
      if (!(Objects.equals(newValue, oldValue))) {
        t.setProperty(parentNodeId, property.getName(), newValue);
      }
    }

    for (final SReferenceLink link : CollectionSequence.fromCollection(concept.getReferenceLinks())) {
      pendingReferences.add(new _FunctionTypes._return_P0_E0<SNode>() {
        public SNode invoke() {
          SNode targetSNode = parentNode.getReferenceTarget(link);
          INodeReference currentTarget = t.getReferenceTarget(parentNodeId, link.getName());
          if (targetSNode == null) {
            if (currentTarget != null) {
              t.setReferenceTarget(parentNodeId, link.getName(), null);
            }
          } else {
            long targetId = nodeMap.getId(targetSNode);
            INode targetNode;
            if (targetId == 0L || !(t.containsNode(targetId))) {
              targetNode = SNodeToNodeAdapter.wrap(targetSNode);
            } else {
              targetNode = new PNodeAdapter(targetId, branch);
            }
            if (!(Objects.equals(currentTarget, targetNode.getReference()))) {
              t.setReferenceTarget(parentNodeId, link.getName(), targetNode.getReference());
            }
          }
          return (SNode) null;
        }
      });
    }

    for (SContainmentLink link : CollectionSequence.fromCollection(concept.getContainmentLinks())) {
      syncChildrenFromMPS(link, t, parentNodeId, parentNode, includeDescendants);
    }
  }

  protected void syncChildrenFromMPS(SContainmentLink link, IWriteTransaction t, long parentNodeId, SNode parentNode, boolean includeDescendants) {
    Map<Long, SNode> syncedNodes = createChildrenSynchronizer(parentNodeId, link.getName()).syncToCloud(t);

    // order
    Iterable<IMapping<Long, SNode>> sortedMappings = MapSequence.fromMap(syncedNodes).sort(new ISelector<IMapping<Long, SNode>, Integer>() {
      public Integer select(IMapping<Long, SNode> it) {
        SNode mpsNode = it.value();
        return SNodeOperations.getIndexInParent(mpsNode);
      }
    }, true);
    int index = 0;
    for (IMapping<Long, SNode> mapping : Sequence.fromIterable(sortedMappings)) {
      long cloudId = mapping.key();
      Iterable<Long> children = t.getChildren(parentNodeId, link.getName());
      long actualId = Optional.ofNullable(Sequence.fromIterable(children).skip(1).first()).orElse(0L);
      if (actualId != cloudId) {
        t.moveChild(parentNodeId, link.getName(), index, cloudId);
      }
      index++;
    }

    if (includeDescendants) {
      for (SNode childNode : Sequence.fromIterable(MapSequence.fromMap(syncedNodes).values())) {
        syncNodeFromMPS(childNode, includeDescendants);
      }
    }
  }

  protected long getOrCreateCloudNode(SNode node, long parentIfCreate, String roleIfCreate) {
    long nodeId = nodeMap.getId(node);
    IWriteTransaction t = getBranch().getWriteTransaction();
    if (nodeId == 0L || !(t.containsNode(nodeId))) {
      nodeId = t.addNewChild(parentIfCreate, roleIfCreate, -1, SConceptAdapter.wrap(node.getConcept()));
      nodeMap.put(nodeId, node);
    }
    return nodeId;
  }

  protected long getOrCreateCloudNode(SNode node) {
    return getOrCreateCloudNode(node, ITree.ROOT_ID, ITree.DETACHED_NODES_ROLE);
  }

  public long getCloudNodeId(SNode node) {
    return nodeMap.getId(node);
  }

  public long getOrSyncToCloud(SNode node, IWriteTransaction t) {
    long cloudId = nodeMap.getId(node);
    if (cloudId == 0L || !(t.containsNode(cloudId))) {
      SNode parent = node.getParent();
      if (parent == null) {
        syncRootNodesFromMPS();
      } else {
        long parentCloudId = getOrSyncToCloud(parent, t);
        syncNodeFromMPS(parent, true);
      }
      cloudId = nodeMap.getId(node);
    }
    return cloudId;
  }

  public void handleMPSNodeAdded(@NotNull final SNodeAddEvent e) {
    new PArea(getBranch()).executeWrite(new Function0<Unit>() {
      public Unit invoke() {
        pendingReferences.runAndFlush(new Runnable() {
          public void run() {
            IWriteTransaction t = getBranch().getWriteTransaction();
            long parentId;
            String role;
            if (e.isRoot()) {
              parentId = modelNodeId;
              role = LINKS.rootNodes$jxXY.getName();
            } else {
              parentId = nodeMap.getId(e.getParent());
              role = e.getAggregationLink().getName();
            }
            if (parentId == 0L || !(t.containsNode(parentId))) {
              return;
            }
            SNode child = e.getChild();
            if (e.isRoot()) {
              long childId = nodeMap.getId(child);
              if (childId == 0L || !(t.containsNode(childId))) {
                childId = t.addNewChild(parentId, role, -1, SConceptAdapter.wrap(SNodeOperations.getConcept(child)));
                nodeMap.put(childId, child);
              } else {
                t.moveChild(parentId, role, -1, childId);
              }
            } else {
              syncChildrenFromMPS(e.getAggregationLink(), t, parentId, e.getParent(), false);
            }
            syncNodeFromMPS(child, true);
          }
        });
        return Unit.INSTANCE;
      }
    });
  }

  public void handleMPSNodeRemoved(@NotNull final SNodeRemoveEvent e) {
    final IBranch branch = getBranch();
    new PArea(branch).executeWrite(new Function0<Unit>() {
      public Unit invoke() {
        IWriteTransaction t = branch.getWriteTransaction();
        long childId = nodeMap.getId(e.getChild());
        if (childId != 0L && t.containsNode(childId)) {
          t.moveChild(ITree.ROOT_ID, ITree.DETACHED_NODES_ROLE, -1, childId);
        }
        return Unit.INSTANCE;
      }
    });
  }

  public void handleReferenceChanged(@NotNull final SReferenceChangeEvent e) {
    final IBranch branch = getBranch();
    new PArea(branch).executeWrite(new Function0<Unit>() {
      public Unit invoke() {
        IWriteTransaction t = getBranch().getWriteTransaction();
        SNode targetSNode = check_l95w85_a0b0a0a1a96(e.getNewValue());
        long sourceId = getOrCreateCloudNode(e.getNode());
        if (targetSNode == null) {
          t.setReferenceTarget(sourceId, e.getAssociationLink().getName(), null);
        } else {
          long targetId = nodeMap.getId(targetSNode);
          INode targetNode;
          if (targetId == 0L || !(t.containsNode(targetId))) {
            targetNode = SNodeToNodeAdapter.wrap(targetSNode);
          } else {
            targetNode = new PNodeAdapter(targetId, branch);
          }
          t.setReferenceTarget(sourceId, e.getAssociationLink().getName(), targetNode.getReference());
        }
        return Unit.INSTANCE;
      }
    });
  }

  public class PendingReferences {
    protected List<_FunctionTypes._return_P0_E0<? extends SNode>> currentReferences;

    public synchronized void runAndFlush(Runnable runnable) {
      if (currentReferences == null) {
        try {
          currentReferences = ListSequence.fromList(new ArrayList<_FunctionTypes._return_P0_E0<? extends SNode>>());
          runnable.run();
        } finally {
          try {
            processPendingReferences();
          } catch (Exception ex) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("Failed to process pending reference", ex);
            }
          }
          currentReferences = null;
        }
      } else {
        runnable.run();
      }
    }

    public synchronized void add(_FunctionTypes._return_P0_E0<? extends SNode> ref) {
      if (currentReferences == null) {
        throw new IllegalStateException("Call runAndFlush first");
      }
      ListSequence.fromList(currentReferences).addElement(ref);
    }

    protected void processPendingReferences() {
      Set<SModel> targetModels = SetSequence.fromSet(new HashSet<SModel>());
      for (_FunctionTypes._return_P0_E0<? extends SNode> r : ListSequence.fromList(currentReferences)) {
        try {
          SNode targetNode = r.invoke();
          SetSequence.fromSet(targetModels).addElement(check_l95w85_a0a1a0a1a6tc(targetNode));
        } catch (Exception ex) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("", ex);
          }
        }
      }

      Iterable<SModel> modelsToImport = SetSequence.fromSet(targetModels).where(new IWhereFilter<SModel>() {
        public boolean accept(SModel it) {
          return it != null && it != model;
        }
      });
      if (Sequence.fromIterable(modelsToImport).isNotEmpty()) {
        final ModelImporter importer = new ModelImporter(model);
        Sequence.fromIterable(modelsToImport).visitAll(new IVisitor<SModel>() {
          public void visit(SModel it) {
            importer.prepare(it.getReference());
          }
        });
        importer.execute();
      }
    }

  }
  private static INode check_l95w85_a0g0a0a0a0a14(INodeReference checkedDotOperand, IArea resolveContext) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.resolveNode(resolveContext);
    }
    return null;
  }
  private static SNode check_l95w85_a0b0a0a1a96(SReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTargetNode();
    }
    return null;
  }
  private static SModel check_l95w85_a0a1a0a1a6tc(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModel();
    }
    return null;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink rootNodes$jxXY = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x69652614fd1c50cL, 0x69652614fd1c514L, "rootNodes");
  }
}
