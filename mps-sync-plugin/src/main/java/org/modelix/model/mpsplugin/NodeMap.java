package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.modelix.model.area.AbstractArea;
import org.modelix.model.area.IAreaReference;
import org.modelix.model.api.IBranch;
import gnu.trove.map.TLongObjectMap;
import org.jetbrains.mps.openapi.model.SNode;
import gnu.trove.map.hash.TLongObjectHashMap;
import gnu.trove.map.TObjectLongMap;
import gnu.trove.map.hash.TObjectLongHashMap;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.IConcept;
import org.jetbrains.annotations.NotNull;
import org.modelix.model.api.IConceptReference;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.modelix.model.api.INode;
import org.modelix.model.api.PNodeAdapter;
import org.modelix.model.area.PArea;
import kotlin.jvm.functions.Function0;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration;
import org.modelix.model.api.INodeReference;
import org.modelix.model.mpsadapters.mps.SNodeReferenceAdapter;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.Objects;
import org.modelix.model.mpsadapters.mps.SNodeToNodeAdapter;

public class NodeMap extends AbstractArea implements IAreaReference {

  @FunctionalInterface
  public interface BranchProvider {
    IBranch getBranch();
  }

  /**
   * Map from Cloud ID to Node
   */
  private TLongObjectMap<SNode> id2node = new TLongObjectHashMap<SNode>();
  /**
   * Map from Node to Cloud ID
   */
  private TObjectLongMap<SNode> node2id = new TObjectLongHashMap<SNode>();

  private BranchProvider branchProvider;

  public NodeMap(BranchProvider branchProvider) {
    this.branchProvider = branchProvider;
  }

  @Nullable
  @Override
  public IConcept resolveConcept(@NotNull IConceptReference reference) {
    return null;
  }

  @NotNull
  @Override
  public IAreaReference getReference() {
    return this;
  }

  public void put(long id, SNode node) {
    id2node.put(id, node);
    node2id.put(node, id);
  }

  public void removeId(long id) {
    SNode node = id2node.remove(id);
    if (node != null) {
      node2id.remove(node);
    }
  }

  public void removeNode(SNode node) {
    long id = node2id.remove(node);
    id2node.remove(id);
  }

  public SNode getNode(long id) {
    return id2node.get(id);
  }

  public long getId(SNode node) {
    return node2id.get(node);
  }

  public boolean hasMappingForCloudNode(long cloudID) {
    return id2node.containsKey(cloudID);
  }

  public SNode getOrCreateNode(long id, _FunctionTypes._return_P0_E0<? extends SAbstractConcept> conceptProducer) {
    SNode node = getNode(id);
    if (node == null) {
      try {
        // The id parameters is the ID of the node in the replicated data structure.
        // We could use any ID for the MPS node, but for the load balancing to work properly,
        // node references should be resolvable independent of the MPS instance.
        SNodeId nodeId;

        // We need to get the associated MPS Node ID, stored in the INode
        final INode iNode = new PNodeAdapter(id, branchProvider.getBranch());
        // We should probably store these values somewhere, to avoid transactions
        String mpsNodeIdAsString = (branchProvider.getBranch().canRead() ? MPSNodeMapping.mappedMpsNodeID(iNode) : new PArea(branchProvider.getBranch()).executeRead(new Function0<String>() {
          public String invoke() {
            return MPSNodeMapping.mappedMpsNodeID(iNode);
          }
        }));

        if (mpsNodeIdAsString == null) {
          // Here, given we have no explicit NodeId in the INode, we use the id of the INode
          // We may want to create a special SNodeId in this case?
          nodeId = new jetbrains.mps.smodel.SNodeId.Regular(id);
        } else {
          nodeId = PersistenceFacade.getInstance().createNodeId(mpsNodeIdAsString);
        }
        Object rawConcept = conceptProducer.invoke();
        SConcept c;
        if (rawConcept instanceof SInterfaceConcept) {
          c = MetaAdapterByDeclaration.asInstanceConcept(((SAbstractConcept) rawConcept));
        } else if (rawConcept instanceof SConcept) {
          c = (SConcept) rawConcept;
        } else {
          throw new RuntimeException("Concept producer returned something unexpected: " + rawConcept);
        }
        node = new jetbrains.mps.smodel.SNode(c, nodeId);
        put(id, node);
      } catch (RuntimeException e) {
        throw new RuntimeException("Issue while trying to create node with id " + id + " and concept " + conceptProducer, e);
      }
    }
    return node;
  }
  @Nullable
  @Override
  public INode resolveOriginalNode(@Nullable INodeReference reference) {
    if (reference instanceof SNodeReferenceAdapter) {
      SNodeReferenceAdapter sNodeReferenceAdapter = ((SNodeReferenceAdapter) reference);
      final SNodeId targetNodeId = sNodeReferenceAdapter.getReference().getNodeId();
      Optional<SNode> sNode = node2id.keySet().stream().filter(new Predicate<SNode>() {
        public boolean test(SNode sNode) {
          return Objects.equals(sNode.getNodeId(), targetNodeId);
        }
      }).findFirst();
      if (sNode.isPresent()) {
        return SNodeToNodeAdapter.wrap(sNode.get());
      } else {
        return null;
      }
    }
    return null;
  }

  @NotNull
  @Override
  public INode getRoot() {
    throw new UnsupportedOperationException();
  }
}
