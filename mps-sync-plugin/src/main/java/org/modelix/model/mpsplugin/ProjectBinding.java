package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.mps.openapi.module.SRepositoryListenerBase;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.modelix.model.api.IBranch;
import kotlin.jvm.functions.Function1;
import org.modelix.model.api.IWriteTransaction;
import kotlin.Unit;
import org.modelix.model.api.ITree;
import org.modelix.model.mpsadapters.mps.SConceptAdapter;
import org.modelix.model.api.IReadTransaction;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.Nullable;
import org.modelix.model.api.ITreeChangeVisitor;
import java.util.Objects;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class ProjectBinding extends Binding {
  private static final Logger LOG = LogManager.getLogger(ProjectBinding.class);

  private long projectNodeId;
  private MPSProject mpsProject;
  private SRepositoryListenerBase repositoryListener = new SRepositoryListenerBase() {
    @Override
    public void moduleAdded(@NotNull SModule p1) {
      enqueueSyncToCloud();
    }

    @Override
    public void moduleRemoved(@NotNull SModuleReference p1) {
      enqueueSyncToCloud();
    }
    private void enqueueSyncToCloud() {
      enqueueSync(SyncDirection.TO_CLOUD, false, null);
    }
  };

  public ProjectBinding(MPSProject mpsProject, long projectNodeId, SyncDirection initialSyncDirection) {
    super(initialSyncDirection);
    this.mpsProject = mpsProject;
    this.projectNodeId = projectNodeId;
    if (LOG.isDebugEnabled()) {
      LOG.debug("Project binding created: " + this);
    }
  }

  @Override
  public String toString() {
    return "Project: " + Long.toHexString(projectNodeId) + " -> " + mpsProject.getName();
  }

  public MPSProject getProject() {
    return this.mpsProject;
  }

  public long getProjectNodeId() {
    return this.projectNodeId;
  }

  @Override
  protected void doActivate() {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Activating: " + this);
    }
    final IBranch branch = getBranch();
    if (projectNodeId == 0L) {
      mpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
        public void run() {
          branch.runWriteT(new Function1<IWriteTransaction, Unit>() {
            public Unit invoke(IWriteTransaction t) {
              projectNodeId = t.addNewChild(ITree.ROOT_ID, "projects", -1, SConceptAdapter.wrap(CONCEPTS.Project$An));
              t.setProperty(projectNodeId, PROPS.name$MnvL.getName(), mpsProject.getName());
              return Unit.INSTANCE;
            }
          });
          enqueueSync(SyncDirection.TO_CLOUD, true, null);
        }
      });
    } else {
      boolean cloudProjectIsEmpty = branch.computeReadT(new Function1<IReadTransaction, Boolean>() {
        public Boolean invoke(IReadTransaction t) {
          Iterable<Long> children = t.getChildren(projectNodeId, LINKS.modules$Bi3g.getName());
          return Sequence.fromIterable(children).isEmpty();
        }
      });
      if (cloudProjectIsEmpty) {
        enqueueSync(SyncDirection.TO_CLOUD, true, null);
      } else {
        enqueueSync(SyncDirection.TO_MPS, true, null);
      }
    }
    mpsProject.getRepository().addRepositoryListener(repositoryListener);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Activated: " + this);
    }
  }

  @Override
  protected void doDeactivate() {
    mpsProject.getRepository().removeRepositoryListener(repositoryListener);
  }

  @Nullable
  @Override
  protected ITreeChangeVisitor getTreeChangeVisitor(final ITree oldTree, final ITree newTree) {
    assertSyncThread();
    return new ITreeChangeVisitor() {
      @Override
      public void containmentChanged(long nodeId) {
      }

      @Override
      public void childrenChanged(long parentId, @Nullable String role) {
        assertSyncThread();
        if (parentId == projectNodeId && Objects.equals(role, LINKS.modules$Bi3g.getName())) {
          enqueueSync(SyncDirection.TO_MPS, false, null);
        }
      }

      @Override
      public void referenceChanged(long nodeId, @Nullable String role) {
      }

      @Override
      public void propertyChanged(long nodeId, @Nullable String role) {
      }
    };
  }

  @Override
  public void doSyncToMPS(@NotNull ITree tree) {
    Map<Long, SModule> mappings = new ProjectModulesSynchronizer(projectNodeId, mpsProject).syncToMPS(tree);
    updateBindings(mappings, SyncDirection.TO_MPS);
  }

  @Override
  public void doSyncToCloud(IWriteTransaction t) {
    Map<Long, SModule> mappings = new ProjectModulesSynchronizer(projectNodeId, mpsProject).syncToCloud(t);
    updateBindings(mappings, SyncDirection.TO_CLOUD);
  }

  private void updateBindings(final Map<Long, SModule> mappings, final SyncDirection syncDirection) {
    Iterable<IMapping<Long, SModule>> mappingsWithoutReadonly = MapSequence.fromMap(mappings).where(new IWhereFilter<IMapping<Long, SModule>>() {
      public boolean accept(IMapping<Long, SModule> it) {
        return !(it.value().isPackaged()) && !(it.value().isReadOnly());
      }
    });

    final Map<Long, ProjectModuleBinding> bindings = MapSequence.fromMap(new HashMap<Long, ProjectModuleBinding>());
    Sequence.fromIterable(getOwnedBindings()).ofType(ProjectModuleBinding.class).visitAll(new IVisitor<ProjectModuleBinding>() {
      public void visit(ProjectModuleBinding it) {
        MapSequence.fromMap(bindings).put(it.getModuleNodeId(), it);
      }
    });

    List<Long> toAdd = Sequence.fromIterable(mappingsWithoutReadonly).select(new ISelector<IMapping<Long, SModule>, Long>() {
      public Long select(IMapping<Long, SModule> it) {
        return it.key();
      }
    }).subtract(SetSequence.fromSet(MapSequence.fromMap(bindings).keySet())).toListSequence();
    List<Long> toRemove = SetSequence.fromSet(MapSequence.fromMap(bindings).keySet()).subtract(Sequence.fromIterable(mappingsWithoutReadonly).select(new ISelector<IMapping<Long, SModule>, Long>() {
      public Long select(IMapping<Long, SModule> it) {
        return it.key();
      }
    })).toListSequence();

    ListSequence.fromList(toRemove).visitAll(new IVisitor<Long>() {
      public void visit(Long it) {
        ProjectModuleBinding binding = MapSequence.fromMap(bindings).get(it);
        binding.deactivate(null);
        binding.setOwner(null);
      }
    });

    ListSequence.fromList(toAdd).visitAll(new IVisitor<Long>() {
      public void visit(Long it) {
        ProjectModuleBinding binding = new ProjectModuleBinding(it, MapSequence.fromMap(mappings).get(it), syncDirection);
        binding.setOwner(ProjectBinding.this);
        binding.activate(null);
      }
    });
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Project$An = MetaAdapterFactory.getConcept(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x37a0917d689de959L, "org.modelix.model.repositoryconcepts.structure.Project");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink modules$Bi3g = MetaAdapterFactory.getContainmentLink(0xa7577d1d4e5431dL, 0x98b1fae38f9aee80L, 0x37a0917d689de959L, 0x37a0917d689de9e2L, "modules");
  }
}
