package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Set;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.apache.log4j.Level;

public class SyncTask implements Runnable {
  private static final Logger LOG = LogManager.getLogger(SyncTask.class);
  public final Binding binding;
  public final SyncDirection direction;
  public final Set<ELockType> requiredLocks;
  private final Runnable implementation;
  private final List<Runnable> callbacks = ListSequence.fromList(new ArrayList<Runnable>());
  private State state = State.NEW;
  public final boolean isInitialSync;

  public SyncTask(Binding binding, SyncDirection direction, boolean initialSync, Set<ELockType> requiredLocks, Runnable implementation) {
    this.binding = binding;
    this.direction = direction;
    this.isInitialSync = initialSync;
    this.implementation = implementation;
    this.requiredLocks = Collections.unmodifiableSet(SetSequence.fromSetWithValues(new HashSet<ELockType>(), requiredLocks));
  }

  @Override
  public String toString() {
    return "task[" + binding + ", " + direction + ", " + requiredLocks + "]";
  }

  @Override
  public synchronized void run() {
    if (state != State.NEW) {
      throw new IllegalStateException("Current state: " + state);
    }
    try {
      state = State.RUNNING;
      if (binding.isActive()) {
        binding.runningTask = this;
        implementation.run();
      } else {
        if (LOG.isEnabledFor(Level.WARN)) {
          LOG.warn("Skipped " + this + ", because the binding is inactive");
        }
        return;
      }
    } finally {
      binding.runningTask = null;
      state = State.DONE;
    }
  }

  public void invokeCallbacks() {
    for (Runnable callback : ListSequence.fromList(callbacks)) {
      try {
        callback.run();
      } catch (Exception ex) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("", ex);
        }
      }
    }
  }

  public boolean isDone() {
    return state == State.DONE;
  }

  public boolean isRunning() {
    return state == State.RUNNING;
  }

  public void whenDone(Runnable callback) {
    if (callback != null) {
      ListSequence.fromList(callbacks).addElement(callback);
    }
  }

  private enum State {
    NEW(),
    RUNNING(),
    DONE()
  }
}
