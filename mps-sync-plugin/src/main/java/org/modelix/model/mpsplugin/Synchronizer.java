package org.modelix.model.mpsplugin;

/*Generated by MPS */

import org.modelix.model.api.ITree;
import org.modelix.model.api.IWriteTransaction;
import java.util.Map;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;

/**
 * Synchronizes an unordered list of children
 */
public abstract class Synchronizer<MPSChildT> {
  private long cloudParentId;
  private String cloudRole;

  public Synchronizer(long cloudParentId, String cloudRole) {
    this.cloudParentId = cloudParentId;
    this.cloudRole = cloudRole;
  }

  public long getCloudParentId() {
    return this.cloudParentId;
  }

  protected Iterable<Long> getCloudChildren(ITree tree) {
    Iterable<Long> children = tree.getChildren(cloudParentId, cloudRole);
    return children;
  }

  protected abstract Iterable<MPSChildT> getMPSChildren();

  protected abstract MPSChildT createMPSChild(ITree tree, long cloudChildId);

  public abstract long createCloudChild(IWriteTransaction t, MPSChildT mpsChild);

  public abstract void removeMPSChild(MPSChildT mpsChild);

  public abstract Map<Long, MPSChildT> associate(ITree tree, List<Long> cloudChildren, List<MPSChildT> mpsChildren, SyncDirection direction);

  public Map<Long, MPSChildT> syncToMPS(final ITree tree) {
    List<Long> expectedChildren = Sequence.fromIterable(getCloudChildren(tree)).toListSequence();
    List<MPSChildT> existingChildren = Sequence.fromIterable(getMPSChildren()).toListSequence();

    final Map<Long, MPSChildT> mappings = associate(tree, expectedChildren, existingChildren, SyncDirection.TO_MPS);

    List<Long> toAdd = ListSequence.fromList(expectedChildren).subtract(SetSequence.fromSet(MapSequence.fromMap(mappings).keySet())).toListSequence();
    List<MPSChildT> toRemove = ListSequence.fromList(existingChildren).subtract(Sequence.fromIterable(MapSequence.fromMap(mappings).values())).toListSequence();

    ListSequence.fromList(toRemove).visitAll(new IVisitor<MPSChildT>() {
      public void visit(MPSChildT it) {
        removeMPSChild(it);
      }
    });
    ListSequence.fromList(toAdd).visitAll(new IVisitor<Long>() {
      public void visit(Long it) {
        MapSequence.fromMap(mappings).put(it, createMPSChild(tree, it));
      }
    });

    return mappings;
  }

  public Map<Long, MPSChildT> syncToCloud(final IWriteTransaction t) {
    List<MPSChildT> expectedChildren = Sequence.fromIterable(getMPSChildren()).toListSequence();
    List<Long> existingChildren = Sequence.fromIterable(getCloudChildren(t.getTree())).toListSequence();

    final Map<Long, MPSChildT> mappings = associate(t.getTree(), existingChildren, expectedChildren, SyncDirection.TO_CLOUD);

    List<MPSChildT> toAdd = ListSequence.fromList(expectedChildren).subtract(Sequence.fromIterable(MapSequence.fromMap(mappings).values())).toListSequence();
    List<Long> toRemove = ListSequence.fromList(existingChildren).subtract(SetSequence.fromSet(MapSequence.fromMap(mappings).keySet())).toListSequence();

    ListSequence.fromList(toRemove).visitAll(new IVisitor<Long>() {
      public void visit(Long it) {
        t.moveChild(ITree.ROOT_ID, ITree.DETACHED_NODES_ROLE, -1, it);
      }
    });
    ListSequence.fromList(toAdd).visitAll(new IVisitor<MPSChildT>() {
      public void visit(MPSChildT it) {
        MapSequence.fromMap(mappings).put(createCloudChild(t, it), it);
      }
    });

    return mappings;
  }

}
