package org.modelix.model.mpsplugin.history;

/*Generated by MPS */

import jetbrains.mps.ide.ui.tree.TextTreeNode;
import org.modelix.model.mpsplugin.ModelServerConnection;
import org.jetbrains.mps.openapi.model.SNode;
import org.modelix.model.lazy.RepositoryId;
import org.modelix.model.client.ActiveBranch;
import org.modelix.model.api.IBranchListener;
import org.modelix.model.api.ITree;
import javax.swing.SwingUtilities;
import org.modelix.model.mpsplugin.CloudIcons;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.modelix.model.mpsplugin.CloudRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import javax.swing.tree.TreeNode;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.modelix.model.mpsplugin.SharedExecutors;
import java.util.List;
import org.modelix.model.area.PArea;
import kotlin.jvm.functions.Function0;
import jetbrains.mps.internal.collections.runtime.IListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.modelix.model.api.IBranch;
import org.modelix.model.api.PNodeAdapter;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class RepositoryTreeNode extends TextTreeNode {

  private ModelServerConnection modelServer;
  private SNode repositoryInfo;
  private RepositoryId repositoryId;
  private ActiveBranch activeBranch;
  private TextTreeNode dataTreeNode = new TextTreeNode("data");
  private TextTreeNode branchesTreeNode = new TextTreeNode("branches");
  private CloudBindingTreeNode bindingsTreeNode;
  private IBranchListener branchListener = new IBranchListener() {
    @Override
    public void treeChanged(ITree oldTree, ITree newTree) {
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          ((CloudView.CloudViewTree) getTree()).runRebuildAction(new Runnable() {
            public void run() {
              updateData();
            }
          }, true);
        }
      });
    }
  };

  public RepositoryTreeNode(ModelServerConnection modelServer, SNode repositoryInfo) {
    super(CloudIcons.REPOSITORY_ICON, SPropertyOperations.getString(repositoryInfo, PROPS.id$baYB));
    try {
      this.modelServer = modelServer;
      this.repositoryInfo = repositoryInfo;
      this.repositoryId = new RepositoryId(SPropertyOperations.getString(repositoryInfo, PROPS.id$baYB));
      this.activeBranch = modelServer.getActiveBranch(new RepositoryId(SPropertyOperations.getString(repositoryInfo, PROPS.id$baYB)));
      CloudRepository cloudRepository = new CloudRepository(modelServer, repositoryId);
      bindingsTreeNode = new CloudBindingTreeNode(cloudRepository.getRootBinding(), cloudRepository);
      setAllowsChildren(true);
      TreeModelUtil.setChildren(this, ListSequence.fromListAndArray(new ArrayList<TreeNode>(), dataTreeNode, branchesTreeNode, bindingsTreeNode));
      activeBranch.addListener(branchListener);
      updateData();
    } catch (RuntimeException e) {
      throw new RuntimeException("Unable to initialize RepositoryTreeNode for repository with id " + SPropertyOperations.getString(repositoryInfo, PROPS.id$baYB), e);
    }
  }

  @Override
  protected void onRemove() {
    super.onRemove();
    activeBranch.removeListener(branchListener);
  }

  public SNode getRepositoryInfo() {
    return repositoryInfo;
  }

  public RepositoryId getRepositoryId() {
    return repositoryId;
  }

  public ModelServerConnection getModelServer() {
    return this.modelServer;
  }

  public void updateChildren() {
    updateBranches();
  }

  public void updateBranches() {
    final Map<SNode, CloudBranchTreeNode> existing = MapSequence.fromMap(new LinkedHashMap<SNode, CloudBranchTreeNode>(16, (float) 0.75, false));
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      public void run() {
        if (Sequence.fromIterable(TreeModelUtil.getChildren(RepositoryTreeNode.this)).isEmpty()) {
          TreeModelUtil.setChildren(RepositoryTreeNode.this, Sequence.<TreeNode>singleton(LoadingIcon.apply(new TextTreeNode("loading ..."))));
        }
        for (CloudBranchTreeNode node : Sequence.fromIterable(TreeModelUtil.getChildren(branchesTreeNode)).ofType(CloudBranchTreeNode.class)) {
          MapSequence.fromMap(existing).put(node.getBranchInfo(), node);
        }
      }
    });

    SharedExecutors.FIXED.execute(new Runnable() {
      public void run() {
        final List<TreeNode> newChildren = new PArea(modelServer.getInfoBranch()).executeRead(new Function0<IListSequence<TreeNode>>() {
          public IListSequence<TreeNode> invoke() {
            return ListSequence.fromList(SLinkOperations.getChildren(repositoryInfo, LINKS.branches$b5_g)).select(new ISelector<SNode, TreeNode>() {
              public TreeNode select(SNode it) {
                TreeNode tn = (MapSequence.fromMap(existing).containsKey(it) ? MapSequence.fromMap(existing).get(it) : new CloudBranchTreeNode(modelServer, it));
                return tn;
              }
            }).toListSequence();
          }
        });
        ThreadUtils.runInUIThreadNoWait(new Runnable() {
          public void run() {
            TreeModelUtil.setChildren(branchesTreeNode, newChildren);
          }
        });
      }
    });
  }

  public void updateData() {
    TreeModelUtil.setTextAndRepaint(dataTreeNode, "data [" + activeBranch.getBranchName() + "]");
    final IBranch branch = activeBranch.getBranch();
    PNodeAdapter rootNode = new PNodeAdapter(ITree.ROOT_ID, branch);
    Iterable<TreeNode> childTreeNodes = Sequence.fromIterable(TreeModelUtil.getChildren(dataTreeNode)).toListSequence();
    if (Sequence.fromIterable(childTreeNodes).count() != 1 || !(Objects.equals(((CloudNodeTreeNode) Sequence.fromIterable(childTreeNodes).first()).getNode(), rootNode))) {
      CloudNodeTreeNode newTreeNode = new CloudNodeTreeNode(branch, rootNode);
      TreeModelUtil.setChildren(dataTreeNode, ListSequence.fromListAndArray(new ArrayList<TreeNode>(), newTreeNode));
    }
    Sequence.fromIterable(TreeModelUtil.getChildren(dataTreeNode)).ofType(CloudNodeTreeNode.class).visitAll(new IVisitor<CloudNodeTreeNode>() {
      public void visit(CloudNodeTreeNode it) {
        it.update();
      }
    });
  }

  private static final class PROPS {
    /*package*/ static final SProperty id$baYB = MetaAdapterFactory.getProperty(0xb6980ebdf01d459dL, 0xa95238740f6313b4L, 0x62b7d9b07cecbcc0L, 0x62b7d9b07cecbcc6L, "id");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink branches$b5_g = MetaAdapterFactory.getContainmentLink(0xb6980ebdf01d459dL, 0xa95238740f6313b4L, 0x62b7d9b07cecbcc0L, 0x62b7d9b07cecbcc4L, "branches");
  }
}
