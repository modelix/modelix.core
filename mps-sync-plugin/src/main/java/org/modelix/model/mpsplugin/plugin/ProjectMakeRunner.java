package org.modelix.model.mpsplugin.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.function.Consumer;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.List;
import jetbrains.mps.messages.IMessage;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.apache.log4j.Level;
import jetbrains.mps.project.Project;
import jetbrains.mps.messages.IMessageHandler;
import java.util.LinkedList;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.make.MakeSession;
import java.util.ArrayList;
import jetbrains.mps.ide.make.actions.MakeActionParameters;
import jetbrains.mps.make.IMakeService;
import jetbrains.mps.make.MakeServiceComponent;
import jetbrains.mps.make.resources.IResource;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.resources.MResource;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class ProjectMakeRunner {
  private static final Logger LOG = LogManager.getLogger(ProjectMakeRunner.class);
  public ProjectMakeRunner() {
  }

  public static Consumer<Tuples._2<String, List<IMessage>>> DEFAULT_SUCCESS_CONSUMER = new Consumer<Tuples._2<String, List<IMessage>>>() {
    @Override
    public void accept(Tuples._2<String, List<IMessage>> res) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Make messages:");
      }
      for (IMessage message : ListSequence.fromList(res._1())) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("  <MAKE> " + message.getKind() + " " + message.getText());
        }
      }
      if (LOG.isInfoEnabled()) {
        LOG.info("Make Project Success: " + res._0());
      }
    }
  };
  public static Consumer<Tuples._2<String, List<IMessage>>> DEFAULT_FAILURE_CONSUMER = new Consumer<Tuples._2<String, List<IMessage>>>() {
    @Override
    public void accept(Tuples._2<String, List<IMessage>> res) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Make messages:");
      }
      for (IMessage message : ListSequence.fromList(res._1())) {
        if (LOG.isInfoEnabled()) {
          LOG.info("  <MAKE> " + message.getKind() + " " + message.getText());
        }
      }
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Make Project Failure: " + res._0());
      }
    }
  };

  public static void execute(final Project mpsProject, boolean cleanMake) {
    execute(mpsProject, cleanMake, null, DEFAULT_SUCCESS_CONSUMER, DEFAULT_FAILURE_CONSUMER);
  }

  private static class MyMessageHandler implements IMessageHandler {
    private List<IMessage> messages = ListSequence.fromList(new LinkedList<IMessage>());


    @Override
    public void handle(@NotNull IMessage message) {
      ListSequence.fromList(messages).addElement(message);
    }
  }

  public static void execute(final Project mpsProject, final boolean cleanMake, List<SModule> modulesToBuild, final Consumer<Tuples._2<String, List<IMessage>>> success, final Consumer<Tuples._2<String, List<IMessage>>> failure) {
    final MyMessageHandler messageHandler = new MyMessageHandler();
    MakeSession session = new MakeSession(mpsProject, messageHandler, cleanMake);
    if (modulesToBuild == null) {
      modulesToBuild = ListSequence.fromListWithValues(new ArrayList<SModule>(), (Iterable<SModule>) mpsProject.getProjectModules());
    }
    final MakeActionParameters params = new MakeActionParameters(mpsProject).modules(modulesToBuild).cleanMake(cleanMake);
    final IMakeService makeService = mpsProject.getComponent(MakeServiceComponent.class).get();
    if (makeService.openNewSession(session)) {
      // empty collection is fine, it's up to make service to report there's nothing to do (odd, but fine for now. Action could have do that instead)
      //
      // ModelValidatorAdapter needs to be refactored not to mix model checking code with UI, which might request
      // write access e.g. on focus lost and eventually lead to 'write from read' issue like
      // FIXME https://youtrack.jetbrains.com/issue/MPS-24020. Proper fix is to split model check into read, and results reporting into EDT.
      // For 3.4 RC, we decided to go with a hack and let SModel instances cross model read boundary
      List<? extends IResource> inputRes = null;
      final ArrayList<SModel> models = new ArrayList<SModel>();
      try {
        inputRes = new ModelAccessHelper(mpsProject.getModelAccess()).runReadAction(new Computable<List<IResource>>() {
          public List<IResource> compute() {
            List<IResource> rv = Sequence.fromIterable(params.collectInput()).toListSequence();
            models.addAll(ListSequence.fromList(rv).translate(new ITranslator2<IResource, SModel>() {
              public Iterable<SModel> translate(IResource it) {
                return ((MResource) it).models();
              }
            }).toListSequence());
            return rv;
          }
        });

      } catch (RuntimeException e) {
        makeService.closeSession(session);
        e.printStackTrace();
        failure.accept(MultiTuple.<String,List<IMessage>>from(e.getMessage(), messageHandler.messages));
        return;
      }

      if (inputRes != null) {
        final Future<IResult> result = makeService.make(session, inputRes);
        Thread t = new Thread(new Runnable() {
          @Override
          public void run() {
            try {
              IResult resultValue = result.get();
              String resDesc = IterableUtils.join(Sequence.fromIterable(resultValue.output()).select(new ISelector<IResource, String>() {
                public String select(IResource it) {
                  return it.describe();
                }
              }), ", ");
              if (resultValue.isSucessful()) {
                success.accept(MultiTuple.<String,List<IMessage>>from("make succeeded. Resource: " + resDesc, messageHandler.messages));
              } else {
                failure.accept(MultiTuple.<String,List<IMessage>>from("make failed. Resources: " + resDesc, messageHandler.messages));
              }
            } catch (Throwable t) {
              t.printStackTrace();
              failure.accept(MultiTuple.<String,List<IMessage>>from(t.getMessage(), messageHandler.messages));
            }
          }
        });
        t.start();
      } else {
        makeService.closeSession(session);
        failure.accept(MultiTuple.<String,List<IMessage>>from("no input", messageHandler.messages));
      }
    }
  }

}
